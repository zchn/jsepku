version:1.0
url:txtfile//test2.txt
length:1849

他们两人有意见分歧。
氧原子结合成分子时会释放出能量。
明年地铁中将可以使用移动电话。
北京大学毕业生不看重大城市户口。
10年是一段很长的时间。
11月3日晚，世界产业工人协会的战术生效了。
1903年莱特兄弟的发明被忽视了，而不是获得了赏识。
1916年5月21日星期日夜晚，日本最大的火山爆发了。
1940年，爱因斯坦成为一名美国公民。
1949年10月1日，毛主席宣布了中华人民共和国的诞生。
1967年他第一次遇到她时，她的头发是灰白的。
1977年他在巴黎遇见她。
1979年每一选举人只准投一个候选人的票。
1979年是我儿子出生的一年。
1991年，感染霍乱的病人多达3026人，其中440人死亡。
1992年是我们艰苦拼搏的一年。
1997年是李素丽最难忘的一年。
1月26日被定为澳大利亚国庆节。
“王”字的笔画有四个。
《战争与和平》是我读过的书中最长的一本。
啊，这是多么美妙的前景！
阿珍她们吃完饭散步去了。
爱国一家，爱国不分先后。
爱因斯坦的引力定律在一次日蚀期间得到了检验。
安不会游泳，是吗？
安不在学音乐，是吗？
安德鲁被送到特为聋人办的学校去了。
安德鲁邀请她一起开车出去玩。
安的孩子们整天都上学，所以她决定去找个工作。
安定团结是实现四个现代化的前提。
安给他一本书。
安没得到彩电，是吗？
安劝我读那本书。
安在农村小屋已经住了六十年，她不想搬到楼房去住。
安葬他的地方很美。
安装灯的人是我的同学。
安自己打开了门。
安昨天不可能看见汤姆。
安昨天可能没看见汤姆。
按公制度量它是多少？
案子的线索断了。
澳大利亚大陆最早是在16世纪由葡萄牙人发现的。
澳大利亚是世界上最大的岛。
八成他不来了。
八点时，他正在吃早饭。
八减三得五。
八月份物价将上涨。
把东西清理干净
把工作分成三六九等是错误的。
把孩子们送上床后，她开始改学生的卷子。
把花盆搬到外面去。
把画挂到墙上！
把火拔一拔
把酒注到瓶里。
把卷子交上来！
把课文再读一遍！
把脸转到这边来
把龙头打开
把乱七八糟的东西清理干净
把那本书扔给我
把那本杂志扔给我
把你的名字告诉我
把你的衣服挂起来
把瓶子放在桌上。
把其余的吃的留到明天。
把全部情况告诉她
把身子探出窗外是很危险的。
把绳子再放松点儿。
把失败都归咎于客观原因是不正确的。
把收音机开小点儿，别干扰人家。


version:1.0
url:txtfile//test1.txt
length:26499

中华人民共和国万岁
交通性法规
请把手拿开

王蒙:《坚硬的稀粥》

               （选自《中国作家》一九八九年第二期）

    我们家的正式成员包括爷爷、奶奶、父亲、母亲、叔叔、婶婶、我、妻子、堂妹、妹夫，和我那个最可爱的瘦高挑儿子。他们的年龄分别是八八岁、八四岁、六三岁、六四岁、六一岁、五七岁、四十岁、四十岁
……
十六岁。梯形结构合乎理想。另外，我们有一位比正式成员还要正式的不可须臾离之的非正式成员――徐姐。她今年五九岁，在我们家操持家务已经四十年，她离不开我们，我们离不开她。面前天赋人权，自然平等。一律称她为“姐”。
    我们一直生活得很平稳，很团结。包括是否认为今夏天气过热、喝茶是喝八块钱一两的龙井还是四毛钱一两的青茶，用香皂用白兰还是紫罗兰还是金盾，大家一律听爷爷的。从来没有过意见分歧，没有过论证争鸣相持不下，没有过纵横捭阖，明争暗斗。连头发我们也是留的一个式样，当然各分男女。
    几十年来，我们每天早晨六点十分起床，六点三十五分，徐姐给我们准备好了早餐：烤馒头片、大米稀饭、腌大头菜。七点十分，各自出发上班上学。爷爷退休以后，也要在这个时间出去到街道委员会执勤。中午十二时，回来，吃徐姐准备好的炸酱面。小憩一会儿，中午一时三十分，再次各自出发上班上学。爷爷则午睡至三时半，起来再次洗脸漱口，坐在躺椅上喝茶读报。到五点左右，爷爷奶奶与徐姐研究当晚的饭。研究是每天都要研究的，而且不论爷爷、奶奶还是徐姐，对这一课题兴致勃勃。但得出的结论大致不差：今晚上么就吃米饭吧。菜嘛，一荤、一半荤半素、两素吧。汤呢，就不做了吧。就做一回吧。研究完了，徐姐进厨房，劈哩啪啦响上三十分钟以后，总要再走出来，再问爷爷奶奶：“瞧我糊涂的，我忘了问您老二位了，咱们那个半荤半素的菜，是切肉片还是肉丝呢？”这个这个，这的确是一个重大的问题。爷爷和奶奶互瞟了一眼，做了个眼色，然后说：“就吃肉片吧。”或者说：“就吃肉丝吧。”然后，意图得到了圆满的贯彻。
    大家满意。首先是爷爷满意。爷爷年轻时候受过很多苦。他常常说：“顿顿吃饱饭，穿囫囵衣裳，家里有一切该有的东西，而又子孙团聚，身体健康，这是过去财主东家也不敢想的日子。你们哪，可别太狂妄了啊，你们哪里知道挨饿是啥滋味？”然后爸爸妈妈叔叔婶婶都声明说，他们没忘记挨饿的滋味。饿起来腹腔胸腔一抽一抽的，脑袋一坠一坠的，腿肚子一沉一沉的，据他们说饿极了正像吃得过多了一样，哇哇地想呕吐。我们全家，以爷爷奶奶为首，都是知足常乐哲学的身体力行者与现今体制的忠实支持者。
    这几年情况突然发生了变化。新风新潮不断涌来。短短几年，家里突然有了彩电、冰箱、洗衣机。而且儿子说话里常常出现英文词儿，爷爷很开明开放，每天下午午睡后从报纸上、晚饭后从广播和电视里吸收新名词新观念。他常征询大家的意见：“看咱们家的生活有什么需要改革改善的没有？”
    大家都说没有，徐姐更是说，但愿这样的日子一代一代传下去，天天如此，年年如此，世世代代，永远如此。我儿子终于提了一个建议，提议以前挤了半天眼睛，好像眼睛里爬进了毛毛虫。他建议，买个收录机。爷爷从善如流，批准了。家里又增添了红灯牌立体声收录机。刚买来时很高兴，你讲一段话，他唱一段戏，你学个猫叫，她念一段报纸，录下来然后放出音来，自己与家人共同欣赏欢呼鼓掌，认为收录机真是个好东西，认为爷爷的父辈祖辈不知收录机为何物，实在令人叹息。两天以后就降了温。买几个“盒儿带”来，唱的还不如收音机电视机里放送的好。于是，收录机放在一边接土蒙尘。大家便认识到，新技术新器物毕竟作用极为局限，远远不如家庭的和谐与秩序更重要。远不如老传统更耐用――还是“话匣子”好哇！
    那一年决定取消午睡，中午只休息四十分钟――一小时，很使全家骚动了一阵子。先说是各单位免费供应午餐，令我们既喜且忧。喜的是白吃饭，忧的是不习惯，果然，吃了两天就纷纷反应上火，拉不出屎来。没有几天宣布免费供应的午餐取消，叫人迷惑。这可怎么办呢？爷爷教育我们处处要带头按政府指的道儿走，于是又买饭盒又带饭，闹腾了一阵子。徐姐也害得失眠、牙疼、长针眼、心率不齐。不久，各机关自动把午休时间延长了。有的虽不明令延长却也自动推后了下午上班时间，但没有推后下班时间。我们家又恢复了中午的炸酱面。徐姐的眼睛不再起包儿，牙齿不再上火，睡觉按时始终，心脏每分钟七十至八十次有规律地跳。
    新风日劲，新潮日猛，万物静观皆自得，人间正道是沧桑。在兹四面反思含悲厌旧，八方涌起怀梦维新之际，连过去把我们树成标兵模范样板的亲朋好友也启发我们要变动变动，似乎是在广州要不干脆是在香港乃至美国出现了新样板。于是爷爷首先提出，由元首制改行内阁制度。由他提名，家庭全体会议（包括徐姐，也是有发言权的列席代表）通过，由正式成员们轮流执政。除徐姐外都赞成，于是首先委托爸爸主持家政，并决议由他来进行膳食维新。
    爸爸一辈子在家内是吃现成饭，做现成活（及分派给他的活）。这回由他负责主持做饭大业，他很不好意思也很为难。遇到买不买茶叶做不做汤吃肉片还是肉丝这样的大事，一概去问爷爷。他不论说什么话做什么事，都习惯于打出爷爷的旗号。“老爷子说了，蚊香要买防虫菊牌的”，“老爷子说了，今晚就不做汤了”，“老爷子说了，洗碗就不要用洗涤剂了，那化学玩意儿兴许有毒。还是温水加碱面，又节省，又干净。”
    这样一来就增加了麻烦。徐姐遇事问爸爸，爸爸不作主，再去问爷爷，问完爷爷再一口一个老爷子说地向徐姐传话，还不如直接去问爷爷便当。直接去问爷爷吧，又怕爸爸挑眼而爷爷嫌烦。爷爷嫌烦也是真的，几次对爸爸说：“这些事你作主嘛，不要再来问我了”，于是爸爸告诉徐姐：“老爷子说了，让我作主，老爷子说了，不让我再问他。”
    叔叔和婶婶有些窃窃私语。语了些什么，不知道。但很可能是既不满于爸爸的无能，又怀疑爸爸是不是拉大旗，假传圣旨，也不满于爷爷的不放手，同样不满于徐姐的噜嗦，乃至不满于大家为何同意了实行内阁制与通过了爸爸这样的内阁人选。
    爷爷有所查觉，好好地开导了一次爸爸，说明下放权力是大趋势。爸爸无奈，答应不再动辄以爷爷的名义行事。爸爸也来了一个下放权力，明确做不做汤与肉片肉丝之间的选择权全由徐姐决定。
    徐姐不答应。“我怎么做得了主啊，”她垂泪垂涕辞谢，惶恐得少吃了一顿饭。大家都鼓励她：“你在我们家做了这么多年，你应该有职有权嘛！你管起来吧，我们支持你！你想买什么就买什么，你想做什么就做什么，你给什么我们就吃什么，我们信任你！”
    徐姐终于破涕为笑，感谢家人对她的抬举。一切照旧，但人们实际上都渐渐挑剔起来。都知道这样是徐姐一手操办的，没有尚方宝剑为来历为依据，从下意识的不敬开始演变出上意识的不满意。首先是我的儿子，接着是堂妹堂妹夫，然后是我妻子和我，开始散播一些讽刺话。“我们的饭是四十年一贯制，快成了文物啦！因循守旧，墨守成规，凝固僵化，不思进取！我们家的生活是落后于时代的典型”“徐姐的局限性太大嘛！文化素质太低嘛！人倒是好，就是水平太低！想不到我们家八十年代过着徐姐水平的生活！”
    徐姐浑然不觉，反倒露出些踌躇意满的苗头。她开始按照她的意思进行某些变革了。首先把早饭里的两碟腌大头菜改为一碟分两碟装，把咸菜上点香油变成无油，把中午的炸酱由小碗肉丁干炸改为水炸，把平均两天喝一次汤改为七天才喝一次汤，把蛋花汤改为酱油葱花做的最简陋的“高汤”。节省下了伙食钱，买了些人参蜂王精送到爷爷屋里，勒我们的裤带向爷爷效忠，令我们敢怒不敢言。尤其可恶的是。儿子汇汇说，做完高汤，她经常自己先盛出一碗葱花最多最鲜最香的汤，在大家用饭以前先饮为快。还有一次，她一面切菜一面在厨房里磕瓜子吃，儿子说，她一定是贪污了伙食费。“权力就是腐蚀，一分权力就是一分腐蚀，百分之百的权力就是百分之百的腐蚀”，儿子振振有词地宣讲着他的新观念。
    父亲以下的人未表示态度。儿子受到了这种沉默鼓舞，便在一次徐姐先喝高汤的时刻向徐姐发起了猛攻：“够了，你这套低水平的饭！自己还先挑葱花儿！从明天起我管，我要让大家过现代化的生活！”
    虽然徐姐哭哭闹闹，众人却没说什么。大家觉得让儿子管管也好，他年轻，有冲劲，有想法，又脱颖而出，符合成才规律。当然，包括我在内，还是多方挽慰了徐姐：“你在我们家做饭四十年，成绩是主要的，谁想抹杀也抹杀不了的！”
    儿子非常激昂地讲了一套理论，“咱们家吃饭是四十年一贯制，不但毫无新意，而且有一条根本性的缺陷，碳水化合物过多而蛋白质不足。缺少蛋白，就会影响生长发育，而且妨碍白血球抗体的再生与活力。其结果，也就造成国民体质的羸弱与素质的低下。在各发达国家，平均日摄取的蛋白质是我国平均日摄取量的七倍，其中动物蛋白，是我们的十四倍。如此下去，个儿没人家高，体形没人家好，力气没有人家大，精神没有人家足。人家一天睡一次，四、五个小时最多六个小时就够用了，从早到晚，精神气十足。我们呢，加上午觉仍然是无精打采。或者你们会说，我们不应与发达国家比。那么，我要说的是，我们汉族的食品结构还比不上北方各兄弟民族－－总不能说兄弟民族的经济发展水准高于我们啊！我们的蛋白质摄入量，与蒙古、维吾尔、哈萨克、朝鲜、以及西南地区的藏族比，也是不能望其项背！这样的食品结构，不变行吗？以早餐为例，早晨吃馒头片稀粥咸菜……我的天啊！这难道是二十世纪八十年代中华大城市具有中上收入的现代人的享受？太可怕了！太愚昧了！稀粥咸菜本身就是东亚病夫的象征！就是慢性自戕！就是无知！就是炎黄子孙的耻辱！就是华夏文明衰落的根源！就是黄河文明式微的兆征！如果我们历来早晨不吃稀粥咸菜而吃黄油面包，1840年的鸦片战争，英国能够得胜吗？1900年的八国联军，西太后至于跑到承德吗？1931年日本关东军敢于发动九・一八事变吗？1937年小鬼子敢发动芦沟桥事变吗？日本军队打过来，一看，中国人人一嘴的白脱－－奶油，他们能不整团整师的休克吗？如果一九四九年以后我们领导及早下决心消灭稀粥咸菜，全国都吃黄油面包外加火腿辣肠鸡蛋酸奶干酪外加果酱蜂蜜朱古力，我国国力、科技、艺术、体育、住房、教育、小汽车平均拥有量不是早就达到世界前列了吗？说到底，稀粥咸菜是我们民族不幸的根源，是我们的封建社会趋稳定欠发展无进步的根源！彻底消灭稀粥咸菜！稀粥咸菜不消灭，中国就没有希望！”
    言者为之动火，听者为之动容。我一则以惊，一则以喜，一则以惧。惊喜的是不知不觉之中儿子不但不再穿开裆裤不再叫我去给他擦屁股而且积累了这么多学问，更新了这么大观念，提出了这么犀利的见解，抓住了这么关键的要害，真是天若有情天亦老，人间正道是儿强！真是身在稀粥咸菜，胸怀黄油火腿，吞吐现代化之八方风云，覆盖世界性之四维空间，着实是后生可畏，世界归根结底是他们的。惧的是小子两片嘴皮子一沾就把积弊抨击了个落花流水，赵括谈兵，马谡守亭，言过其实，大而无当，清谈误家，终无实用。积我近半个世纪之经验，凡把严重的大问题说得小葱拌豆腐一清二白千军万马中取敌将首级易如掌都不用翻者，早就会在亢奋劲儿过去以后患阳痿症的！只此一大耳儿，为传宗接代计，实痿不得也！
    果然，堂妹鼻子眼里哼了一声，嘟囔道：“说得倒便利，要是有那么多黄油面包，我看现代化也就完成了。”
    “啊？”儿子正在气盛之时，大叫：“好家伙！六十年代尼・谢・赫鲁晓夫提倡土豆烧牛肉的共产主义，八十年代，姑姑搞面包加黄油的现代化，何共相似乃尔！现代化意味着工业的自动化农业的集约化科学的超前化国防的综合化思维的任意化名词的难解化艺术的变态化争论的无边化学者的清谈化观念的莫名化和人的硬气功化及特意功能化。化海无涯，黄油为楫；乐土无路，面包成桥！当然，黄油面包不可能向炸弹一样地由假想敌投掷过来，这我还不知道么？我非弱智，岂无常识？但我们总要提出问题提出目标，国之无目标犹人之无头，未知其可也！”
    “好嘛好嘛，大方向还是一致的嘛，不要吵了，”爷爷说，大家便不再吵。
    吾儿励精图治，第二天，果然，黄油面包拥生鸡蛋牛奶咖啡。徐姐与奶奶不吃咖啡牛奶，叔叔给他们出主意用葱花炝锅，加花椒、桂皮、茴香、姜皮、胡椒、紫菜、干辣椒，加热冒烟后放广东老抽－－虾子酱油，然后用这些潲子加到牛奶咖啡里，压服牛奶咖啡的洋气腥气。我尝了一口，果然易于承受接受多了。我也求加潲子，看到儿子的杀人犯似的眼神，才为子牺牲口味，硬灌洋腥热饮。唉，“四二一”综合症下的中国小皇帝呀！他们会把我国带到哪里去？    
    三天之后，全家震荡。徐姐患急性中毒性肠胃炎，住院并疑有并发肠胃癌症。奶奶患非甲非乙型神经性肝硬化。爷爷自吃西餐后便秘，爸爸与叔叔两位孝子轮流侍候，用竹筷粉碎捅捣，收效甚微。堂妹患肠梗阻，腹痛如绞，紧急外科手术。堂妹夫牙痛烂嘴角。我妻每饭后必呕吐，把西餐吐光后回娘家偷偷补充稀饭咸菜，不敢让儿子知道。尤为可怕的是，三天便花掉了过去一个月的伙食费。儿子声称，不加经费再供应稀粥咸菜亦属不可能矣！事已至此，需要我出面，我找了爸爸叔叔，提出应立即解除儿子的权柄，恢复家庭生活的正常化！
    爸爸和叔叔只有去找爷爷，爷爷只有去找徐姐。而徐姐住院，并且声明她出院以后也不再做饭了，如果人们感到她没用，可以赶走她。爷爷只得千声明万表态，绝无此意，而且重申了自己的人生原则。人生在世，情义为重，徐姐在我家，情义俱全，比爷爷的嫡亲还要亲，比爷爷的骨肉还要近。徐姐在我们这里一天，我们就与徐姐同甘共苦一天。哪怕家里只剩了一个馒头，一定有徐姐的一瓣。哪怕家里只剩了一碗凉水，一定有徐姐的三勺。发了财有徐姐的好处。受了伤有徐姐的安置。岂有用完了人又把人蹬掉之理哉！爷爷说得激动，慷慨陈词，热泪横流。徐姐听得仔细，肝胆俱暖，涕泪交织。最后被医护人员认定他们的接触不利于病人康复，便劝说爷爷含泪退去。
    爷爷回家召集了全体会议，声明自己年迈力衰，对于吃什么怎么吃及其它有关事宜无成见，更无意独揽大权，但你们一定要找我，我只有去找徐姐。徐姐又因你们的怨言而寒了心，因吃重孙子的西餐，而寒了肠胃，我也就无法再管了，谁爱吃什么吃什么吧。“我自己没得吃，饿死也好。”爷爷说。
    大家面面相觑，纷纷表态。都说还是爷爷管得好，半个世纪，老少平安，四代和睦。堂妹妹表示她准备每天给爷爷做饭吃。就是说，她、妹夫、爷爷、奶奶、徐姐是一组，吃他们自身的饭。爸爸声明，他可以与妈妈一组，但不管我和妻。因为我和妻有一个新潮儿子，不可能与他们吃到一块儿。我也声明只和妻一搭。然后叔叔婶婶一搭。然后儿子单奔儿。堂妹夫见状，似乎相当满意，发挥了一句：“各吃各的吧，这样才更现代些！四世同堂一起吃饭，太象红楼梦时侯的事了。再说，太多人围着一饭桌，又挤，又容易传染肝炎哟！”堂妹反问：“在美国，有这样的大家庭吗？有这么好几代人克服掉代沟一起吃饭吗？”爷爷的表情似乎有些凄然。
    分开吃了两天就吃不下了。十一点多，堂妹这一组占着火做饭，由于挟爷爷之资深威重，别人只能望火兴叹。然后爸爸，然后叔叔。然后我能做饭时已是下午二时，只好不做先去上班，然后晚饭同样是望灶兴叹。然后讨论计议论证各置一灶的问题。煤气罐不可能，上次为解决全家共用的一个煤气罐，跑人情十四人次，请客七次，送画两张，送烟五条，送酒八瓶，历时十三个月零十三天，用尽吃奶拉屎之力。买得蜂窝火炉亦需手续，无证买不到煤。有证买到了煤也没有地方搁。如果按照现代意识设四个灶，首先要扩张厨房面积三十平方米，当然最好是设立四个厨房，比最好更好是增加五套房子，人的消费要求真如脱僵野马，怪道谈消费过热，愈谈愈热。于是恍然不盖房子而谈现代意识观念更新隐私权云云全他妈的是站着说话不腰疼的扯淡！
    分灶软科学没有研究出子丑寅卯，一罐子煤气九天用完了。自从今年液化石油气限量供应以来，一年只有十几个票，只有一罐子气用二十五天以上才能保证全家用熟食、饮开水。九天用完，一年的票四个月用完，另外八个月找谁去？不但破坏了自己的生活秩序。更是破坏了国家的安排！
    众人惊慌，唉声叹气，牢骚满腹，闲言四起。有的说煤气用完以后改吃生面糊糊。有的说可以限制每组做饭时间十七分钟。有的说现在就分灶吃饭是生产关系超越了生产力的发展水平。有的说越改越糟还不如爷爷掌管徐姐当政。有的抨击美国，说美国人如禽兽，不讲孝悌忠信，当然没有大家庭。我们有优秀的家庭道德传统，为什么要学美国呢？大家不好意思也不忍再去打搅爷爷，便不约而同地去找堂妹夫。
    堂妹夫是全家唯一喝过洋水之人，近年来做西服两套，领带三条，赴美进修六个月，赴日参观十天，赴联邦德国转游过七个城市。见多识广，雍容有度，会用九种语言道“谢谢”与“请原谅”，是我家有真才实学之人。只因属于外姓，深知自己的身份，一贯不争不论不骄不躁，知白守黑，随遇而安。故而深受敬重。
    这次见我们虔诚急切，而且确实一家陷入困难的怪圈，他便掏出心窝子，亮出了真货色。他说：
    “依我之见，咱家的根本问题还是体制。吃不吃烤馒头片，其实是小问题。问题是，由谁来决定，以怎样的程序决定吃的内容？封建家长制吗？论资排辈吗？无政府主义吗？随机性即谁想做什么就吃什么吗？按照基本上的食谱吃吗？必然性即先验性吗？要害问题在于民主，缺少了民主吃了好的也不觉得好。缺乏民主吃得一塌糊涂却没有人挺身而出负责任从自身改革起。没有民主就只能稀里糊涂地吃，吃白糖而不知其甜，吃苦瓜而不知其苦，甜与苦都与你自己的选择不相干嘛。没有民主就会忽而麻木不仁，丧失吃饭的主体意识，使吃饭主体异化为造粪机器。忽而一团混乱，各行其是，轻举妄动，急功近利，短期行为，以邻为壑，使吃饭主体膨胀为有胃无头的妖魔！没有民主就没有选择，没有选择就失落了自己！”
    大家听了，都觉如醍醐灌顶，点头称是不止。
    堂妹夫受到了鼓舞，继续说到：“论资排辈，在一个停滞的农业社会里，不失为一种秩序，这种秩序特别适合文盲与白痴。即使先天弱智者也可以理解、可以接受这样一种呆板与平静的，我要说是僵死的秩序。然而，它扼杀了竞争，扼杀了人的主动性创造性变导性，而没有变导就没有人类，没有变导我们就都还是猴子。而且，论资排辈压制了新生力量。一个人精力最旺盛、思想最活跃、追求最热烈的时期，亦该是四十岁以前。然而，这个时候他们只能被压在最下层……”
    我的儿子叹道：“太对了。”他激动地流出了眼泪。
    我向儿子悄悄摆了摆手。他的西式早餐化纲领失败之后，在家中的形象不佳，多少有点冒险家、清谈家、成事不足败事有余甚至造反派的色彩。包括堂妹与堂妹夫，对吾儿也颇看着不顺眼。他跳高了，只能给堂妹夫帮倒忙。
    我问：“你说的对。但我们到底怎么办呢！”堂妹夫说；“发扬民主，选举！民主选举，这就是关键，这就是穴位，这就是牵牛鼻子，这就是中心一环！大家来竞选嘛！每个人都谈谈，好比都来投标，你收多少钱，需要大家尽多少义务，准备给大家提供什么样的食品，你个人需要什么样的待遇报酬，一律公开化、透明化、规范化、条文化、法律化、程序化、科学化、制度化，最后，一切靠选票，靠选民公决，少数服从多数。少数服从多数，这本身就是新观念新精神新秩序，既抵制僵化，也抵制无政府主义随心所欲……”
    爸爸认真思考了一大会儿，脸上的皱纹因思考而变得更加深刻。最后，他表态说：“行，我赞成。不过这里有两道关口。一个是老爷子是不是赞成，一个是徐姐……”
    堂妹说：“爷爷那儿没事。爷爷思想最新了，管伙食，他也早嫌烦了。麻烦的是徐姐……”
    我儿子急了，他喊道：“徐姐算是哪一家的人五人六？她根本不是咱们家的成员，她没有选举权与被选举权。”
    妈妈不高兴地说：“妈妈的孙儿呀！你少插话好不好！别看徐姐不姓咱们的姓，别看徐姐不算咱们族人，你说什么来着？说她没有选举权与被选举权是不？可咱们做什么事情不跟她说通了你就甭想办去！我来这个家一辈子了，我不知道吗？你们知道个啥？”
    堂妹和妹夫也分化了，争论开了。妹夫认为，承认徐姐的特殊地位，就是不承认民主，承认民主就不能承认徐姐的特殊地位。这是一个根本性的原则问题，没有调和余地。堂姐认为，敢情站着说话不腰疼，脱离了实际的空话高调有什么用？轻视徐姐就是不尊重传统，不尊重传统也就站不住脚，站不住则一切变革的方案便都成了云端的幻想。而云端的改革也就是拒不改革。堂妹对自己的丈夫说话不客气，她干脆指出：“别以为你出过几趟国会说几句外国话就有什么了不起，其实你在我们家，还没有徐姐要紧呢！”
    堂妹夫听罢变色，冷笑一分半钟，拂袖而去。
    过了些日子，还是叔叔出来说话，指出两个关口其实是一个关口。徐姐虽然顽固，但她事事都听爷爷的，爷爷通了她也就通了，根本不需要人为地制造民主进程与徐姐之间的激烈斗争，更不要激化这种人为制造出来的斗争。
    大家一听，言之有理。恍然大悟。种种烦恼，原是庸人自扰。矛盾云云，你说它大它就大，你说它小它就小，说它有就有，说它无就无。寻找各种不同意见的契合点，形成宽松融洽，亲密无间，这才是真功夫！一时充满信心，连堂妹夫与我儿子也都乐得合不拢嘴。
    公推爸爸叔叔二人去谈，果然一谈便通。徐姐对选举十分反感，说：“做这些花式子干吗？”但她又表示，她此次生病住院后，对一切事概不介入，概不反对。“你们大家吃苍蝇我也跟着吃苍蝇，你们愿意吃蚊子我就跟着吃蚊子，什么事不用问我。”她对自己有无选举权也既不关心，又无意见，她明确表示，不参加我们的任何家事讨论。
    看来徐姐已经自动退出了历史舞台，大家公推由堂妹夫主持选举。选举日的临近给全家带来了节日气氛，又是扫除，有是抹玻璃，又挂字画，又摆花瓶和插入新产品塑料绢花。民主带来新气象，信然。终于到了这一天，堂妹夫穿上了访问欧美时穿过的灰色西服，戴上黑领结，象个交响乐队的指挥，主持这一盛事。他首先要求参加竞选的人以“我怎样主持家政”为题做一演说。
    无人答应。一派沉寂。听得见厨房里的苍蝇声。
    堂妹夫惊奇道：“怎么？没有人愿意竞选吗？不是都有见解有意见有看法吗？”
    我说：“妹夫，你先演说好不好，你做个样子嘛！现在大家还没有民主习惯，怪不好意思的。”
    堂妹马上打断我的话：“别让他说话，又不是他的事！”
    堂妹夫态度平和，富有绅士派头地解释说：“我不参加竞选。我提出来搞民主的意思可不是为了个人争权。如果你们选了我，就只能是为民主抹黑了！再说，我现在正办自费留学，已经与北美洲大洋洲几个大学联系好了，只等在黑市上换够了美元，我就与各位告辞了。各位如果有愿意帮我垫借一些钱的，我十分欢迎，现在借的时候是人民币，将来保证还外币！这个……”
    面面相觑，全都泄了气。而且不约而同地心中暗想：竞选主持家政，不是吃饱了撑的吗？自己吹一通，卖狗皮膏药，目无长上而又伤害左邻右舍，这样的圈套，我们才不钻呢？真让你主持？你能让人人满意吗？有现成饭不吃去竞选，不是吃错了药又是什么？便又想，搞啥子民主选举哟：几十年没有民主选举我们也照旧吃稀饭，咸菜，炸酱面！几十年没有民主选举我们也没有饿死，没有撑死，没有吃砖头喝狗尿，也没有把面条吃到鼻子眼屁股眼里！吃饱了撑的闹他爷爷的民主，最后闹他个拉稀的拉稀，饿肚的饿肚完事！中国人就是这样，不折腾浮肿了绝不踏实。
    但既然说了民主就总要民主一下。既然说了选了就总要选举一下。既然凑到一起了而且爷爷也来了就总要行礼如仪。而且，谁又能说民主选举一定不好呢？万一选好了，从此吃得又有营养又合味，又滋阴又壮阳，又益血又补气，既增强体质又无损线条与萧洒，既有色又有香又有味，记省菜钱又节约能源，既合乎卫生标准又不多费手续，既无油烟又无噪音，既人人有权过问又个个不伤脑筋，既有专人负责又不独断专行，既不吃剩饭又绝不浪费粮食，既吃蚶子又不得肝炎，既吃鱼虾又不腥气……如此等等，民主选举的结果如果能这等好，看哪个天杀的不赞成民主选举。
    于是开始选举。填写选票，投票，监票计票。发出票十一张，收回票十一张，本次投票有效。白票四张，即未写任何候选人。一张票写着：谁都行，相当于白票。计白票五张。选徐姐的，两票。爷爷三票。我儿子，一票。
    怎么办？爷爷得票最多，但不是半数，也不是三分之一。算不算当选？事先没说。便请教堂妹夫。堂妹夫说世上有种“法”，一种是成文法一种是不成文法。例如美国总统的连任期，宪法并无规定，实际上又是法，因为大家都如此做。民主的基本概念是少数服从多数。何谓多数？相对多数？简单多数（即二分之一以上）？绝对多数（即三分之二以上）？这要看传统，也要看观念。至于我们这次的选举，由于是初次试行，又都是至亲骨肉父子兄弟自己人，那就大家怎么说怎么好。
    堂妹说既然爷爷得票最多自然是爷爷当选，这已经不是也绝对不可能是封建家长意识而是现代民主意识。堂妹进一步发挥说，在我们家，封建家长意识的问题其实并不存在，更不是主要危险，主要矛盾。需要警惕的倒是在反封建的幌子下的无政府主义、自由主义、自我中心、唯我主义、超前消费主义、享乐主义，美国的月亮比中国圆主义，洋教条主义。
    我的儿子突然激动起来，他严正地宣布，他所获得的一票，并非自己投了自己的。他说到这里，我只觉的四周目光向我集中，似乎是我选了儿子！我搞了选人唯亲的不正之风。我的脸刷地红起来，并想谁会这样想？他为什么这样想？他知不知道我并没有选儿子而且即使选了儿子也不是什么不正之风，因为不选儿子我也只能选父亲选叔叔选母亲选妻子选堂妹，而按照时髦的弗洛伊德学说，堂妹又何曾会比儿子生分？儿子说不定还有杀父娶母的俄狄浦斯情结呢他们知道吗？为什么儿子一说话他们都琢磨我呢？
    我的儿子喊起来了，他说他得了一票说明人心未死火种未绝，烈火总将熊熊燃烧。他说他之所以要关心我家的膳食改革，完全出自一种无私的奉献精神，出自对传统的人民主义的珍视和对每一个人的泛爱。说到爱他眼角里渗出了黄豆大的泪珠。他说我们家虽然有秩序但是缺乏爱。而无爱的秩序正如无爱的婚姻，其实是不道德的。他说其实他早就可以脱离摆脱我家膳食系统的羁绊，他可以走自己的路改吃蜗牛吃干酪吃芦笋金枪鱼吃龙虾吃小牛肉吃肯德基烤鸡三明治麦当劳与苹果派桂皮冰淇淋布丁。他说他非常爱自己的姑姑但是他不能接受姑姑的观点，虽然姑姑的观点听起来很让人舒服顺耳。
    这时叔叔插话说（注意，是插话而不是插嘴，插嘴是不礼貌的，插话却是一种亲切、智慧、民主，干脆说是一种抬举。）堂妹关于当前应警惕的主要矛盾与主要危险的提法不符，与正式的提法不符。恐怕最好不要过分强调某一面的问题是主要危险。因为半个世纪行医的经验已经证明，如果你指出便秘是主要危险，就会引起普遍拉稀，并导致泻药的脱销与对医生的逆反心理。反之，如果你指出泻肚是主要危险就会引起普遍的直肠干燥，并导致痔疮的诱发乃至因为上火而导致打架。火气火气，气由火生，火需水克。五行协调，方能无病。所以，既要防便秘也要防拉稀。便秘不好拉稀也不比便秘好。便秘了就治便秘拉稀了就治拉稀。最好是既不便秘也不拉稀。他讲得这样好恍惚获得了几许掌声。
    鼓完了掌才发现问题没有解决。而由于热烈的讨论五行生克及新陈代谢的进程似乎受到了促进，人人都饿了。便说既然爸爸得票多还是爸爸管吧。
    爸爸却不赞成。他说做饭的问题其实是个技术问题而不是思想问题、观念问题、辈分（级别）问题、职务问题、权力问题、地位问题与待遇问题。因此，我们不应该选举什么领导人，而是评选最佳的炊事员，一切看做饭烧火炒菜的技术。
    我儿子表示欢呼，大家也感觉确实有了新的思路，新的突破口，别人则表示今天已经没有时间，肚子已经饿了。尽管由谁来管理吃饭的问题还处在研讨、论证的过程中，到了钟点，饭却仍然是照吃不误。讨论得有结果要吃饭，讨论得没有结果也还是要吃饭。拥护讨论的结果要吃饭，反对讨论的结果也还是要吃饭。让吃饭，要吃饭，不让吃饭，也还是要吃饭。于是……纷纷自行吃饭去了。

    为了评比炊事技艺，设计了许多程序，包括：每人要蒸馒头一屉，做米饭一锅，炒鸡蛋两个，切咸菜丝一盘，煮稀饭一碗，做红烧肘子一盘等等。为了设计这一程序，我们全家进行了三十个白天三十个夜晚的研讨。有争论、冲动、吵架、落泪也有和好。最后累的气也喘不出，尿也尿不出，走路也走不动。既伤了和气，又增长了团结交流了思想感情。既累了精神，又引起了较大的兴趣。说起要炒两个鸡蛋的时候，人们笑得前仰后合，好象受到了某种神秘的暗示性的鼓舞。说到切咸菜的时候，人们忧心的阴阴沉沉，好象一下子衰老了许多。终于最后归根结底，炊事技艺评出来了。评的结果十分顺通，谁也没有说话。
    评的结果名次是：一等一级，爷爷、奶奶。一等二级，父亲、母亲、叔叔、婶婶。二等一级，我，妻，堂妹，堂妹夫。三等一级，是我那瘦高挑的儿子。大家又怕儿子受到打击，便一致同意儿子虽是三等，却要颁给他“希望之星特别荣誉奖”。虽然他又有特别荣誉又成了“希望之星”，但他仍然是三等。总之，理论名称方法常新，而秩序，是永恒的。

    许多时日过去了。人们模模糊糊地意识到，既然秩序永恒，理论名称方法的研讨实验便会自然降温。做饭与吃饭问题已不再引起分歧的意见与激动的情绪。做饭与吃饭究竟是技术问题体制问题还是文化观念问题还是其它别样的过去想也没想过的问题，也不再困扰我们的心。看来这些问题不讨论也可以照样吃饭。徐姐平安地去世了，无疾而终。她睡了一个午觉，一直睡到下午四点还不醒，去看她，已停止了呼吸。全家人都怀念她尊敬她追悼她。儿子到中外合资企业工作去了，他可能已经实现了天天吃黄油面包和一大堆动物性蛋白质的理想。节假日回家，当我们征询他对于吃什么的意见的时候，他说各种好的都吃过了，现在想吃的只有稀饭与腌大头菜，还有高汤和炸酱面。说完了，他自我解嘲说：观念易改，口胃难移呀！叔叔与婶婶分到了新落成的单元楼房，搬走了。他们没有管道煤气与抽风换气扇孔的厨房，在全新的厨房里做饭，做过红烧肘子，也做过炒鸡蛋，但他们说更经常地仍然是吃稀饭，烤馒头片，腌大头菜，高汤，炸酱面。堂妹夫终于出国“深造”，一面留学一面就业了，他后来接走了堂妹，并来信说：“在国外，我们最常吃的就是稀饭咸菜，一吃稀饭咸菜就充满了亲切怀念之情，就不再因为身在异乡异国而苦闷就如同回到了我们的亲切朴质的家。有什么办法呢？也许我们的细胞里已经有了稀饭咸菜的遗传基因了吧？”
    我，爸爸和爷爷幸福地生活在一起。我们吃的鸡鸭鱼肉蛋奶糖油都在增加，我们都胖了。我们饭桌上摆的菜肴愈来愈丰富多彩和高档化了。有过炒肉片也有过葱炒海参。有过油炸花生米也有过奶油炸糕。有过凉拌粉皮也有过蟹肉沙拉甚至还吃过一次鲍鱼鲜贝。鲍鱼来了又去了，海参上了又下了，沙拉吃了又忘了。只有稀饭咸菜永存。即使在一顿盛宴上吃过山珍海味，这以后还要加吃稀饭咸菜。然后口腔食道肠胃肝脾胰腺才能稳定正常地运转。如果忘了加稀饭咸菜，马上就会肚子胀肚子痛。也许还会长癌。我们至今未患肠胃癌，这都是稀饭咸菜的功劳啊！稀饭和咸菜是我们的食品的不可改变的纲。其它只是配搭－－陪衬，或者叫做“目”。
    徐姐去世以后，做饭的重任落到妈妈头上。每顿饭以前，妈妈照例要去问爷爷奶奶。“汤呢，就做了吧，就不做了吧。肉呢？切成肉片还是肉丝？”古老的问题既忠诚又伤感。是一种程序更是一种道德情绪。在这种表面平淡乃至空洞的问答中寄托了对徐姐的怀念，大家感到徐姐虽死犹生，风范常存。爷爷屡次表示只要有稀饭，咸菜，烤馒头片与炸酱面，做不做汤的问题，肉片与肉丝的问题以及加什么高级山珍海味的问题，他不准备过问，也希望妈妈不要用这种愈来愈难拍板的问题去打搅他。妈妈唯唯。但不问总觉得心里不踏实。饭做熟了，唤了大家来吃，却要东张西望如坐针毡，揣摩大家特别是爷爷的脸色。爷爷咳嗽，妈妈就要小声嘟囔，是不是稀饭里有了沙子呢？是不是咸菜不够咸或者过于咸了呢？小声嘟囔却又不敢直截了当地征求意见。虽然，即使问过爷爷也不能保证稀饭里不掺沙子。
    于是，再一天，妈妈还是要在黄昏将临的时候忠顾地－－由于自觉罗嗦而分外诚惶诚恐地去问爷爷－－肉片还是肉丝？问话的声调委婉动人。而爷爷答话的声调呢？叫作慈祥苍劲。即使是回答：不要问我。”也总算有回答。妈妈就会心安理得地去完成她的炊事。
    一位英国朋友－－爸爸四十年代的老友来华旅行，在我们家住了一个星期。最初，我们专门请了一位上海来的西餐厨师给他做面包蛋糕忌司牛排。英国朋友直率地说：“我不是为吃西餐或者名为西餐实际上四不象的东西而来的，把你们的具有古老传统和独特魅力的饭给我弄一点吃吧，求求你们了，行不行？”怎么办呢？只好很不好意思地招待他吃稀饭和咸菜。
    “多么朴素！多么温柔！多么舒服！多么文雅……只有古老的东方才有这样神秘的膳食！”英国博士赞叹着。我把他的称赞稀饭咸菜的标准牛津味儿的英语录到了“盒儿带”上，放给瘦高挑儿子听。



version:1.0
url:txtfile//Md5.cpp
length:9225

/*
 * RFC 1321 compliant MD5 implementation,
 * by Christophe Devine <devine@cr0.net>;
 * this program is licensed under the GPL.
 */
#include "Md5.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define GET_UINT32(n,b,i)                                       \
{                                                               \
    (n) = (uint32) ((uint8 *) b)[(i)]                           \
      | (((uint32) ((uint8 *) b)[(i)+1]) <<  8)                 \
      | (((uint32) ((uint8 *) b)[(i)+2]) << 16)                 \
      | (((uint32) ((uint8 *) b)[(i)+3]) << 24);                \
}

#define PUT_UINT32(n,b,i)                                       \
{                                                               \
    (((uint8 *) b)[(i)]  ) = (uint8) (((n)      ) & 0xFF);      \
    (((uint8 *) b)[(i)+1]) = (uint8) (((n) >>  8) & 0xFF);      \
    (((uint8 *) b)[(i)+2]) = (uint8) (((n) >> 16) & 0xFF);      \
    (((uint8 *) b)[(i)+3]) = (uint8) (((n) >> 24) & 0xFF);      \
}

//extern pthread_mutex_t mutexMemory;

void CMD5::md5_starts( struct md5_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
}

void CMD5::md5_process( struct md5_context *ctx, uint8 data[64] )
{
    uint32 A, B, C, D, X[16];

    GET_UINT32( X[0],  data,  0 );
    GET_UINT32( X[1],  data,  4 );
    GET_UINT32( X[2],  data,  8 );
    GET_UINT32( X[3],  data, 12 );
    GET_UINT32( X[4],  data, 16 );
    GET_UINT32( X[5],  data, 20 );
    GET_UINT32( X[6],  data, 24 );
    GET_UINT32( X[7],  data, 28 );
    GET_UINT32( X[8],  data, 32 );
    GET_UINT32( X[9],  data, 36 );
    GET_UINT32( X[10], data, 40 );
    GET_UINT32( X[11], data, 44 );
    GET_UINT32( X[12], data, 48 );
    GET_UINT32( X[13], data, 52 );
    GET_UINT32( X[14], data, 56 );
    GET_UINT32( X[15], data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))

#define P(a,b,c,d,k,s,t)                                \
{                                                       \
    a += F(b,c,d) + X[k] + t; a = S(a,s) + b;           \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
    P( C, D, A, B,  2, 17, 0x242070DB );
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
    P( D, A, B, C,  5, 12, 0x4787C62A );
    P( C, D, A, B,  6, 17, 0xA8304613 );
    P( B, C, D, A,  7, 22, 0xFD469501 );
    P( A, B, C, D,  8,  7, 0x698098D8 );
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
    P( B, C, D, A, 11, 22, 0x895CD7BE );
    P( A, B, C, D, 12,  7, 0x6B901122 );
    P( D, A, B, C, 13, 12, 0xFD987193 );
    P( C, D, A, B, 14, 17, 0xA679438E );
    P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
    P( D, A, B, C,  6,  9, 0xC040B340 );
    P( C, D, A, B, 11, 14, 0x265E5A51 );
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
    P( A, B, C, D,  5,  5, 0xD62F105D );
    P( D, A, B, C, 10,  9, 0x02441453 );
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
    P( D, A, B, C, 14,  9, 0xC33707D6 );
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
    P( B, C, D, A,  8, 20, 0x455A14ED );
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
    P( C, D, A, B,  7, 14, 0x676F02D9 );
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F
    
#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
    P( D, A, B, C,  8, 11, 0x8771F681 );
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
    P( B, C, D, A, 14, 23, 0xFDE5380C );
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
    P( D, A, B, C,  0, 11, 0xEAA127FA );
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
    P( B, C, D, A,  6, 23, 0x04881D05 );
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
    P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
    P( D, A, B, C,  7, 10, 0x432AFF97 );
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
    P( B, C, D, A,  5, 21, 0xFC93A039 );
    P( A, B, C, D, 12,  6, 0x655B59C3 );
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
    P( B, C, D, A,  1, 21, 0x85845DD1 );
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
    P( C, D, A, B,  6, 15, 0xA3014314 );
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
    P( A, B, C, D,  4,  6, 0xF7537E82 );
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
}

void CMD5::md5_update( struct md5_context *ctx, uint8 *input, uint32 length )
{
    uint32 left, fill;

    if( ! length ) return;

    left = ( ctx->total[0] >> 3 ) & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length <<  3;
    ctx->total[1] += length >> 29;

    ctx->total[0] &= 0xFFFFFFFF;
    ctx->total[1] += ctx->total[0] < length << 3;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, fill );
        md5_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    {
        md5_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, length );
    }
}

static uint8 md5_padding[64] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void CMD5::md5_finish( struct md5_context *ctx, uint8 digest[16] )
{
    uint32 last, padn;
    uint8 msglen[8];

    PUT_UINT32( ctx->total[0], msglen, 0 );
    PUT_UINT32( ctx->total[1], msglen, 4 );

    last = ( ctx->total[0] >> 3 ) & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    md5_update( ctx, md5_padding, padn );
    md5_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    PUT_UINT32( ctx->state[1], digest,  4 );
    PUT_UINT32( ctx->state[2], digest,  8 );
    PUT_UINT32( ctx->state[3], digest, 12 );
}

void CMD5::GenerateMD5(unsigned char* buffer,int bufferlen)
{
	struct md5_context context;
	md5_starts (&context);
	md5_update (&context, buffer, bufferlen);
	md5_finish (&context,(unsigned char*)m_data);
}

CMD5::CMD5()
{
	for(int i=0;i<4;i++)
		m_data[i]=0;
}

CMD5::CMD5(unsigned long* md5src)
{
	memcpy(m_data,md5src,16);
}
int _httoi(const char *value)
{
  struct CHexMap
  {
    char chr;
    int value;
  };
  const int HexMapL = 16;
  CHexMap HexMap[HexMapL] =
  {
    {'0', 0}, {'1', 1},
    {'2', 2}, {'3', 3},
    {'4', 4}, {'5', 5},
    {'6', 6}, {'7', 7},
    {'8', 8}, {'9', 9},
    {'a', 10}, {'b', 11},
    {'c', 12}, {'d', 13},
    {'e', 14}, {'f', 15}
  };
  //pthread_mutex_lock(&mutexMemory);
  char *mstr = strdup(value);
  //pthread_mutex_unlock(&mutexMemory);
  char *s = mstr;
  int result = 0;
  if (*s == '0' && *(s + 1) == 'X') s += 2;
  bool firsttime = true;
  while (*s != '\0')
  {
    bool found = false;
    for (int i = 0; i < HexMapL; i++)
    {
      if (*s == HexMap[i].chr)
      {
        if (!firsttime) result <<= 4;
        result |= HexMap[i].value;
        found = true;
        break;
      }
    }
    if (!found) break;
    s++;
    firsttime = false;
  }
  //pthread_mutex_lock(&mutexMemory);
  free(mstr);
  //pthread_mutex_unlock(&mutexMemory);
  return result;
}


CMD5::CMD5(const char* md5src)
{
	if (strcmp(md5src,"")==0)
	{
		for(int i=0;i<4;i++)
			m_data[i]=0;
		return;
	}
	for(int j = 0; j < 16; j++ )
    {
		char buf[10];
		strncpy(buf,md5src,2);
		md5src+=2;
        ((unsigned char*)m_data)[j] = _httoi(buf);
    }
}

CMD5 CMD5::operator +(CMD5 adder)
{
	unsigned long m_newdata[4];
	for(int i=0;i<4;i++)
		m_newdata[i]=m_data[i]^(adder.m_data[i]);
	return CMD5(m_newdata);
}

bool CMD5::operator ==(CMD5 cmper)
{
	return (memcmp(cmper.m_data ,m_data,16)==0);
}

//void CMD5::operator =(CMD5 equer)
//{
//	memcpy(m_data,equer.m_data ,16);
//}

string CMD5::ToString()
{
    char output[33];
    for(int j = 0; j < 16; j++ )
    {
        sprintf( output + j * 2, "%02x", ((unsigned char*)m_data)[j]);
    }
    return string(output);
}




version:1.0
url:txtfile//Dict.cpp
length:655

// Dict handling

#include "Dict.h"

CDict::CDict()
{
	OpenDict();
}

CDict::~CDict()
{
	mapDict.clear();
}

void CDict::OpenDict()
{
	FILE *fpDict;
	if ((fpDict = fopen(DICTFILENAME.c_str(), "r")) == NULL) {
		cout << "Can not open the Dictionary file!";
		exit(1);
	}
  
	int id, freq;
	char word[16];
	while (fscanf(fpDict, "%d %s %d", &id, word, &freq) != EOF) {
		//fscanf(fpDict, "%d %s %d", &id, word, &freq);
		mapDict.insert(map<string,int>::value_type (word, 0));
	}
  
	fclose(fpDict);
  
}

bool CDict::IsWord(string& str) const
{
	if (mapDict.find(str) != mapDict.end())
		return true;
	return false;
}


version:1.0
url:txtfile//HzSeg.cpp
length:5339

// HzSeg handling

#include "HzSeg.h"
#include "Dict.h"

const unsigned int MAX_WORD_LENGTH = 31;
const string SEPARATOR(" ");		// delimiter between words

CHzSeg::CHzSeg()
{
}

CHzSeg::~CHzSeg()
{
}

// Using Max Matching method to segment a character string.
string CHzSeg::SegmentHzStrMM (CDict &dict, string s1) const
{
	string s2="";				// store segment result
	while (!s1.empty()) { 
		unsigned int len=s1.size();
		if (len>MAX_WORD_LENGTH) len=MAX_WORD_LENGTH;

		string w=s1.substr(0, len);// the candidate word
		bool isw=dict.IsWord(w);

		while (len>2 && isw==false) {	// if not a word
			len-=2;		// cut a word
			w=w.substr(0, len);
			isw=dict.IsWord(w);
		}
		s2 += w + SEPARATOR;

		s1 = s1.substr(w.size());
	}

	return s2;
}


bool CHzSeg::good_char(unsigned char c) const
{
  if((c >= '0' && c <= '9')
     || (c >= 'A' && c <= 'Z')
     || (c >= 'a' && c <= 'z')
     || (c == '\'')
     || c >= 128)
    return true;
  else
    return false;
}


// process a sentence before segmentation
string CHzSeg::SegmentSentenceMM (CDict &dict, string s1) const
{
	string s2="";
	unsigned int i,len;

	while (!s1.empty()) {
		unsigned char ch=(unsigned char) s1[0];
                len = s1.size();
                if(!good_char(ch)){//add by chenzhijie
                  unsigned int j = 1;
                  while(j < len && !good_char(s1[j])) j++;
                  s1 = s1.substr(j);
                  continue;
                }
                
		if(ch<128) { // deal with ASCII
			i=1;
			if(len > MAX_WORD_LENGTH) len=MAX_WORD_LENGTH;
			while (i<len && ((unsigned char)s1[i]<128) 
                               && good_char(s1[i])) { // LF, CR
				i++;
			}
                        
                        s2 += s1.substr(0, i) + SEPARATOR;

			if (i <= s1.size())	// added by yhf
				s1=s1.substr(i);
			else break;		// yhf

			continue;

		} else { 
			if (ch<176) { // 中文标点等非汉字字符
				i = 0;
				len = s1.length();

				while(i<len && ((unsigned char)s1[i]<176) && ((unsigned char)s1[i]>=161)
              && (!((unsigned char)s1[i]==161 && ((unsigned char)s1[i+1]>=162 && (unsigned char)s1[i+1]<=168)))
              && (!((unsigned char)s1[i]==161 && ((unsigned char)s1[i+1]>=171 && (unsigned char)s1[i+1]<=191)))
              && (!((unsigned char)s1[i]==163 && ((unsigned char)s1[i+1]==172 || (unsigned char)s1[i+1]==161) 
              || (unsigned char)s1[i+1]==168 || (unsigned char)s1[i+1]==169 || (unsigned char)s1[i+1]==186
              || (unsigned char)s1[i+1]==187 || (unsigned char)s1[i+1]==191))) { 
					i=i+2; // 假定没有半个汉字
				}

				if (i==0) i=i+2;

				// 不处理中文空格
				if (!(ch==161 && (unsigned char)s1[1]==161)) { 
					if (i <= s1.size())	// yhf
						// 其他的非汉字双字节字符可能连续输出
						s2 += s1.substr(0, i) + SEPARATOR; 
					else break; // yhf
				}

				if (i <= s1.size())	// yhf
					s1=s1.substr(i);
				else break;		//yhf

				continue;
			}
		}
    

    // 以下处理汉字串

		i = 2;
		len = s1.length();

		while(i<len && (unsigned char)s1[i]>=176) 
//    while(i<len && (unsigned char)s1[i]>=128 && (unsigned char)s1[i]!=161)
			i+=2;

		s2+=SegmentHzStrMM(dict, s1.substr(0,i));

		if (i <= len)	// yhf
			s1=s1.substr(i);
		else break;	// yhf
	}

	return s2;
}

// translate the encoded URL(%xx) to actual chars
void CHzSeg::Translate(char* SourceStr) const
{
	int i=0;
	int j=0;
	char *tempstr,tempchar1,tempchar2;

	tempstr = (char*)malloc(strlen(SourceStr) + 1);
	if(tempstr == NULL){
		return;
	}

	while (SourceStr[j])
	{
		if ((tempstr[i]=SourceStr[j])=='%'){
			if (SourceStr[j+1]>='A')
				tempchar1=((SourceStr[j+1]&0xdf)-'A')+10;
			else
				tempchar1=(SourceStr[j+1]-'0');
			if (SourceStr[j+2]>='A')
				tempchar2=((SourceStr[j+2]&0xdf)-'A')+10;
			else
				tempchar2=(SourceStr[j+2]-'0');
				tempstr[i]=tempchar1*16+tempchar2;
			j=j+2;
		}
		i++;
		j++;
	}
	tempstr[i]='\0';
	strcpy(SourceStr,tempstr);

	if(tempstr) free(tempstr);
}

/*
 * segment the image URL by '/'
 * omit the domain name
 */
string CHzSeg::SegmentURL(CDict &dict, string url) const
{
	string::size_type idx, nidx;
	char *curl = (char *)url.c_str();
	this->Translate(curl);
	url = curl;
	if((idx = url.find("http://", 0)) != string::npos)
	{
		if((nidx = url.find("/", 7)) != string::npos)
		{
			url = url.substr(nidx + 1);	// cut the part of sitename
		}
	}
	idx = 0;
	while((idx = url.find("/", idx)) != string::npos)
	{
		url.replace(idx, 1, SEPARATOR);	// replace "/" with SEPARATOR "/  "
		idx += 3;
	}
	if((idx = url.rfind(".")) != string::npos)
	{
		url = url.erase(idx);	// erase the file extension
	}

	url += "/  ";
	
	// segment the string whose length is greater than 8 (4 HZ_chars)
	idx = 0; nidx = 0;
	bool isover = false;
	string stmp;
	while(!isover)
	{
		if((nidx = url.find(SEPARATOR, idx)) == string::npos)
			isover = true;
		if(nidx - idx > 0)
		{
			stmp = url.substr(idx, nidx-idx);
			stmp = SegmentSentenceMM(dict, stmp);
			if ( stmp.size() >= 3)
				stmp.erase(stmp.length() - 3);	// erase the tail "/  "
			url = url.replace(idx, nidx-idx, stmp);
			idx += stmp.length() + 3;
		}
		else if(nidx == string::npos && idx < url.length())
		{
			stmp = url.substr(idx);
			stmp = SegmentSentenceMM(dict, stmp);
			stmp.erase(stmp.length() - 3);
			url = url.substr(0, idx) + stmp;
		}
		else
			idx = nidx + 3;
	}
	
	return url;
	
}




version:1.0
url:txtfile//DocSegment.cpp
length:3864

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <vector>

#include "Md5.h"
#include "Url.h"
#include "Document.h"
#include "ChSeg/Dict.h"
#include "ChSeg/HzSeg.h"
#include "StrFun.h"

CDict iDict;

using namespace std;

const unsigned int HEADER_BUF_SIZE = 1024;
//const unsigned int MAX_DOC_ID = 12932;		// you should change according "Doc.idx"
const unsigned int MAX_DOC_ID = 21312;

int main(int argc, char* argv[])
{
	string strLine, strFileName=argv[1];
	CUrl iUrl;
	vector<CUrl> vecCUrl;
	CDocument iDocument;
	vector<CDocument> vecCDocument;
	unsigned int docId = 0;

	//ifstream ifs("Tianwang.raw.2559638448");
	ifstream ifs(strFileName.c_str());
	if (!ifs) {
		cerr << "Cannot open tianwang.img.info for input\n";
                return -1;
        }

	ifstream ifsUrl("Url.idx.sort_uniq");
        if (!ifsUrl) {
                cerr << "Cannot open Url.idx.sort_uniq for input\n";
                return -1;
        }
	ifstream ifsDoc("Doc.idx");
        if (!ifsDoc) {
                cerr << "Cannot open Doc.idx for input\n";
                return -1;
        }

	while (getline(ifsUrl,strLine)){
		char chksum[33];
		int  docid;

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%s%d", chksum, &docid );
		iUrl.m_sChecksum = chksum;
		iUrl.m_nDocId = docid;
		vecCUrl.push_back(iUrl);
	}

	while (getline(ifsDoc,strLine)){
		int docid,pos,length;
		char chksum[33];

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%d%d%d%s", &docid, &pos, &length,chksum );
		iDocument.m_nDocId = docid;
		iDocument.m_nPos = pos;
		iDocument.m_nLength = length;
		iDocument.m_sChecksum = chksum;
		vecCDocument.push_back(iDocument);
	}

/*
	// find page according to a url
	// ===================================
	string c,key;
	cin >> c;
	if( c == "c" ) return(0);


	CMD5 iMD5;
	iMD5.GenerateMD5( (unsigned char*)c.c_str(), c.size() );
	key = iMD5.ToString();

	int low=0, high = vecCUrl.size()-1, mid = 0;

	cout << "url: " << c << " len: " << c.size() << endl;
	cout << "md5: " << key << endl;
	cout << "high: " << high << endl;

	bool bFound = false;
	while (low <= high ){
		mid = (low+high)/2;

		if ( key == vecCUrl[mid].m_sChecksum ){
			docId = vecCUrl[mid].m_nDocId;
			// cout << docId << endl;
			bFound = true;
			break;
		} else if ( key < vecCUrl[mid].m_sChecksum ){
			high = mid -1;
		} else {
			low = mid + 1;
		}
	}

	if (!bFound){ 
		cout << "not found" << endl;
		return(0);
	}

	return(0);
	//==============================
*/


	strFileName += ".seg";
	ofstream fout(strFileName.c_str(), ios::in|ios::out|ios::trunc|ios::binary);
	for ( docId=0; docId<MAX_DOC_ID; docId++ ){

		// find document according to docId
		int length = vecCDocument[docId+1].m_nPos - vecCDocument[docId].m_nPos -1;
		char *pContent = new char[length+1];
		memset(pContent, 0, length+1);
		ifs.seekg(vecCDocument[docId].m_nPos);
		ifs.read(pContent, length);

		char *s;
		s = pContent;

		// skip Head
		int bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;


		// skip header
		bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;

		//iDocument.m_sBody = s;
		iDocument.RemoveTags(s);
		iDocument.m_sBodyNoTags = s;

		delete[] pContent;
		string strLine = iDocument.m_sBodyNoTags;

                CStrFun::ReplaceStr(strLine, "&nbsp;", " ");
		CStrFun::EmptyStr(strLine); // set " \t\r\n" to " "


		// segment the document
		CHzSeg iHzSeg;
		strLine = iHzSeg.SegmentSentenceMM(iDict,strLine);
		fout << docId << endl << strLine;
		fout << endl;
		
	}

	return(0);
}


version:1.0
url:txtfile//pb1.txt
length:21

在海湾大学生活像白纸


version:1.0
url:txtfile//invert.cpp
length:1306

#include<iostream>

#include<fstream>
#include<string>
#include<iomanip>
using namespace std;
const int TERM_LEN=16;
struct word_info
{
	string words;
	string id;
};
int invert(string path)
{
	ifstream in_piidx_sort(path.c_str());
	if(!in_piidx_sort.is_open())
	{
		cerr<<"[ERROR]:in-file can't be opened"<<endl;
		return -1;
	}
	word_info *words_info;
	words_info=new word_info[2];
	string out_name=path;
	int len=out_name.length();
	len-=11;
	out_name.erase(len);
	out_name+="iidx";
	ofstream out_iidx(out_name.c_str());
	in_piidx_sort>>words_info[0].words;
	in_piidx_sort>>words_info[0].id;
	out_iidx<<setw(TERM_LEN)<<left<<words_info[0].words;
	out_iidx<<setw(TERM_LEN)<<left<<words_info[0].id;
	while(!in_piidx_sort.eof())
	{
		in_piidx_sort>>words_info[1].words;
		in_piidx_sort>>words_info[1].id;
		if(words_info[1].words==words_info[0].words) 
		{
			out_iidx<<setw(TERM_LEN)<<left<<words_info[1].id;
		}
		else
		{
			out_iidx<<endl<<setw(TERM_LEN)<<left<<words_info[1].words;
			out_iidx<<setw(TERM_LEN)<<left<<words_info[1].id;
		}
		words_info[0].words=words_info[1].words;
		words_info[0].id=words_info[1].id;
		words_info[1].words="";
		words_info[1].id="";
	}
	return 0;
}
int main(int argc,char *argv[])
{
	string file_name=argv[1];
	if(invert(file_name) != 0){
		return -1;
	}
	return 0;
}

version:1.0
url:txtfile//crawl.cpp
length:1928

#include<iostream>
#include<fstream>
#include<string>
#include<cstring>

using namespace std;

#include<sys/types.h>
#include<dirent.h>

string RAWFILENAME;

int crawl(ofstream &raw,const char *dir_name)
{
  DIR *dir;
  dir = opendir(dir_name);
  if(dir == NULL){
    cerr<<"[ERROR]:Error in opening dir "<<dir_name<<endl;
    return -1;
  }
  struct dirent *sub;
  for(sub = readdir(dir); sub != NULL; sub = readdir(dir)){
    if(strcmp(sub->d_name,".")==0
       ||strcmp(sub->d_name,"..")==0
       ||strcmp(sub->d_name,RAWFILENAME.c_str())==0) continue;
    if(sub->d_type == DT_DIR){
      //cerr<<"[DEBUG]:I'm a dir"<<endl;
      crawl(raw,(string(dir_name)+"/"+sub->d_name).c_str());
    }
    if(sub->d_type == DT_REG){
      //cerr<<"[DEBUG]:I'm a file "<<sub->d_name<<endl;
      ifstream in((string(dir_name)+"/"+sub->d_name).c_str());
      if(!in){
        cerr<<"[ERROR]:Fail to open file "<<dir_name<<'/'<<sub->d_name<<endl;
        continue;
      }
      raw<<"version:1.0"<<endl;
      raw<<"url:"<<dir_name<<'/'<<sub->d_name<<endl;
      int length;
      in.seekg(0,ios_base::end);
      length = in.tellg();
      in.seekg(0,ios_base::beg);
      raw<<"length:"<<length<<endl;
      raw<<endl;
      while(!in.eof()){
        string tmp;
        getline(in,tmp);
        raw<<tmp<<endl;
      }
      raw<<endl;
    }
  }
  return 0;
}

int main(int argc, char **argv)
{
  string path = *argv;

  while(path[path.length()-1] == '/'){
    path.erase(path.length()-1);
  }
  
  unsigned int pos = path.rfind('/');
  if(pos == string::npos)
    RAWFILENAME = path+".raw";
  else
    RAWFILENAME = path.substr(pos)+".raw";
    
  ofstream raw((path+"/"+RAWFILENAME).c_str());
  if(!raw){
    cerr<<"[ERROR]:Error when opening tianwang raw file "<<argv[1]<<"/"<<RAWFILENAME<<" to write!"<<endl;
    return -1;
  }

  if(crawl(raw,argv[1]) != 0){
    raw.close();
    return -1;
  }

  raw.close();
  return 0;
}


version:1.0
url:txtfile//testtext.txt
length:3444

第三章  输入输出函数及控制流程语句

    本章主要介绍Turbo C2.0标准输入输出函数和文件的输入输出函数。通过本
节的学习可以使读者掌握Turbo C2.0的屏幕输出、键盘输入输出以及磁盘文件的
读写函数, 并能开始进行一些简单的程序的编写。
    控制流程语句主要包括: 条件语句、循环语句和开关语句。


    1.1  标准输入输出函数

    1.1.1 格式化输入输出函数
    Turbo C2.0 标准库提供了两个控制台格式化输入、 输出函数printf( ) 和
scanf(), 这两个函数可以在标准输入输出设备上以各种不同的格式读写数据。
printf()函数用来向标准输出设备(屏幕)写数据; scanf() 函数用来从标准输入
设备(键盘)上读数据。下面详细介绍这两个函数的用法。
    一、printf()函数
    printf()函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出
信息。在编写程序时经常会用到此函数。printf()函数的调用格式为:
      printf("<格式化字符串>", <参量表>);
    其中格式化字符串包括两部分内容: 一部分是正常字符,  这些字符将按原
样输出; 另一部分是格式化规定字符, 以"%"开始, 后跟一个或几个规定字符,
用来确定输出内容格式。
    参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出
参数个数一样多, 各参数之间用","分开, 且顺序一一对应,  否则将会出现意想
不到的错误。
    1. 格式化规定符
    Turbo C2.0提供的格式化规定符如下:
━━━━━━━━━━━━━━━━━━━━━━━━━━
   符号                  作用
──────────────────────────
    %d              十进制有符号整数
    %u              十进制无符号整数
    %f              浮点数
    %s              字符串
    %c              单个字符
    %p              指针的值
    %e              指数形式的浮点数
    %x, %X          无符号以十六进制表示的整数
    %0              无符号以八进制表示的整数
    %g              自动选择合适的表示法
━━━━━━━━━━━━━━━━━━━━━━━━━━
    说明:
    (1). 可以在"%"和字母之间插进数字表示最大场宽。
     例如:  %3d   表示输出3位整型数, 不够3位右对齐。
            %9.2f 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,
                  小数点占一位, 不够9位右对齐。
            %8s   表示输出8个字符的字符串, 不够8个字符右对齐。
    如果字符串的长度、或整型数位数超过说明的场宽, 将按其实际长度输出。
但对浮点数, 若整数部分位数超过了说明的整数位宽度, 将按实际整数位输出;
若小数部分位数超过了说明的小数位宽度, 则按说明的宽度以四舍五入输出。
    另外, 若想在输出值前加一些0, 就应在场宽项前加个0。
    例如:   %04d  表示在输出一个小于4位的数值时, 将在前面补0使其总宽度
为4位。
    如果用浮点数表示字符或整型量的输出格式, 小数点后的数字代表最大宽度,
小数点前的数字代表最小宽度。
    例如: %6.9s 表示显示一个长度不小于6且不大于9的字符串。若大于9,  则
第9个字符以后的内容将被删除。
    (2). 可以在"%"和字母之间加小写字母l, 表示输出的是长型数。
    例如:   %ld   表示输出long整数
            %lf   表示输出double浮点数
    (3). 可以控制输出左对齐或右对齐, 即在"%"和字母之间加入一个"-" 号可
说明输出为左对齐, 否则为右对齐。
    例如:   %-7d  表示输出7位整数左对齐
            %-10s 表示输出10个字符左对齐
    2. 一些特殊规定字符
━━━━━━━━━━━━━━━━━━━━━━━━━━
    字符                           作用
──────────────────────────
     \n                   换行
     \f                   清屏并换页
     \r                   回车
     \t                   Tab符
     \xhh                 表示一个ASCII码用16进表示,
                          其中hh是1到2个16进制数
━━━━━━━━━━━━━━━━━━━━━━━━━━
    由本节所学的printf()函数, 并结合上一节学习的数据类型, 编制下面的程
序, 以加深对Turbo C2.0数据类型的了解。


version:1.0
url:txtfile//.svn/all-wcprops
length:550

K 25
svn:wc:ra_dav:version-url
V 33
/svn/!svn/ver/4/trunk/src/txtfile
END
Md5.cpp
K 25
svn:wc:ra_dav:version-url
V 41
/svn/!svn/ver/4/trunk/src/txtfile/Md5.cpp
END
DocSegment.cpp
K 25
svn:wc:ra_dav:version-url
V 48
/svn/!svn/ver/4/trunk/src/txtfile/DocSegment.cpp
END
crawl.cpp
K 25
svn:wc:ra_dav:version-url
V 43
/svn/!svn/ver/4/trunk/src/txtfile/crawl.cpp
END
Md5.h
K 25
svn:wc:ra_dav:version-url
V 39
/svn/!svn/ver/4/trunk/src/txtfile/Md5.h
END
.tianwang.raw
K 25
svn:wc:ra_dav:version-url
V 47
/svn/!svn/ver/4/trunk/src/txtfile/.tianwang.raw
END


version:1.0
url:txtfile//.svn/format
length:2

8


version:1.0
url:txtfile//.svn/text-base/Md5.cpp.svn-base
length:9225

/*
 * RFC 1321 compliant MD5 implementation,
 * by Christophe Devine <devine@cr0.net>;
 * this program is licensed under the GPL.
 */
#include "Md5.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define GET_UINT32(n,b,i)                                       \
{                                                               \
    (n) = (uint32) ((uint8 *) b)[(i)]                           \
      | (((uint32) ((uint8 *) b)[(i)+1]) <<  8)                 \
      | (((uint32) ((uint8 *) b)[(i)+2]) << 16)                 \
      | (((uint32) ((uint8 *) b)[(i)+3]) << 24);                \
}

#define PUT_UINT32(n,b,i)                                       \
{                                                               \
    (((uint8 *) b)[(i)]  ) = (uint8) (((n)      ) & 0xFF);      \
    (((uint8 *) b)[(i)+1]) = (uint8) (((n) >>  8) & 0xFF);      \
    (((uint8 *) b)[(i)+2]) = (uint8) (((n) >> 16) & 0xFF);      \
    (((uint8 *) b)[(i)+3]) = (uint8) (((n) >> 24) & 0xFF);      \
}

//extern pthread_mutex_t mutexMemory;

void CMD5::md5_starts( struct md5_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
}

void CMD5::md5_process( struct md5_context *ctx, uint8 data[64] )
{
    uint32 A, B, C, D, X[16];

    GET_UINT32( X[0],  data,  0 );
    GET_UINT32( X[1],  data,  4 );
    GET_UINT32( X[2],  data,  8 );
    GET_UINT32( X[3],  data, 12 );
    GET_UINT32( X[4],  data, 16 );
    GET_UINT32( X[5],  data, 20 );
    GET_UINT32( X[6],  data, 24 );
    GET_UINT32( X[7],  data, 28 );
    GET_UINT32( X[8],  data, 32 );
    GET_UINT32( X[9],  data, 36 );
    GET_UINT32( X[10], data, 40 );
    GET_UINT32( X[11], data, 44 );
    GET_UINT32( X[12], data, 48 );
    GET_UINT32( X[13], data, 52 );
    GET_UINT32( X[14], data, 56 );
    GET_UINT32( X[15], data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))

#define P(a,b,c,d,k,s,t)                                \
{                                                       \
    a += F(b,c,d) + X[k] + t; a = S(a,s) + b;           \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
    P( C, D, A, B,  2, 17, 0x242070DB );
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
    P( D, A, B, C,  5, 12, 0x4787C62A );
    P( C, D, A, B,  6, 17, 0xA8304613 );
    P( B, C, D, A,  7, 22, 0xFD469501 );
    P( A, B, C, D,  8,  7, 0x698098D8 );
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
    P( B, C, D, A, 11, 22, 0x895CD7BE );
    P( A, B, C, D, 12,  7, 0x6B901122 );
    P( D, A, B, C, 13, 12, 0xFD987193 );
    P( C, D, A, B, 14, 17, 0xA679438E );
    P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
    P( D, A, B, C,  6,  9, 0xC040B340 );
    P( C, D, A, B, 11, 14, 0x265E5A51 );
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
    P( A, B, C, D,  5,  5, 0xD62F105D );
    P( D, A, B, C, 10,  9, 0x02441453 );
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
    P( D, A, B, C, 14,  9, 0xC33707D6 );
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
    P( B, C, D, A,  8, 20, 0x455A14ED );
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
    P( C, D, A, B,  7, 14, 0x676F02D9 );
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F
    
#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
    P( D, A, B, C,  8, 11, 0x8771F681 );
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
    P( B, C, D, A, 14, 23, 0xFDE5380C );
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
    P( D, A, B, C,  0, 11, 0xEAA127FA );
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
    P( B, C, D, A,  6, 23, 0x04881D05 );
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
    P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
    P( D, A, B, C,  7, 10, 0x432AFF97 );
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
    P( B, C, D, A,  5, 21, 0xFC93A039 );
    P( A, B, C, D, 12,  6, 0x655B59C3 );
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
    P( B, C, D, A,  1, 21, 0x85845DD1 );
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
    P( C, D, A, B,  6, 15, 0xA3014314 );
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
    P( A, B, C, D,  4,  6, 0xF7537E82 );
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
}

void CMD5::md5_update( struct md5_context *ctx, uint8 *input, uint32 length )
{
    uint32 left, fill;

    if( ! length ) return;

    left = ( ctx->total[0] >> 3 ) & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length <<  3;
    ctx->total[1] += length >> 29;

    ctx->total[0] &= 0xFFFFFFFF;
    ctx->total[1] += ctx->total[0] < length << 3;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, fill );
        md5_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    {
        md5_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, length );
    }
}

static uint8 md5_padding[64] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void CMD5::md5_finish( struct md5_context *ctx, uint8 digest[16] )
{
    uint32 last, padn;
    uint8 msglen[8];

    PUT_UINT32( ctx->total[0], msglen, 0 );
    PUT_UINT32( ctx->total[1], msglen, 4 );

    last = ( ctx->total[0] >> 3 ) & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    md5_update( ctx, md5_padding, padn );
    md5_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    PUT_UINT32( ctx->state[1], digest,  4 );
    PUT_UINT32( ctx->state[2], digest,  8 );
    PUT_UINT32( ctx->state[3], digest, 12 );
}

void CMD5::GenerateMD5(unsigned char* buffer,int bufferlen)
{
	struct md5_context context;
	md5_starts (&context);
	md5_update (&context, buffer, bufferlen);
	md5_finish (&context,(unsigned char*)m_data);
}

CMD5::CMD5()
{
	for(int i=0;i<4;i++)
		m_data[i]=0;
}

CMD5::CMD5(unsigned long* md5src)
{
	memcpy(m_data,md5src,16);
}
int _httoi(const char *value)
{
  struct CHexMap
  {
    char chr;
    int value;
  };
  const int HexMapL = 16;
  CHexMap HexMap[HexMapL] =
  {
    {'0', 0}, {'1', 1},
    {'2', 2}, {'3', 3},
    {'4', 4}, {'5', 5},
    {'6', 6}, {'7', 7},
    {'8', 8}, {'9', 9},
    {'a', 10}, {'b', 11},
    {'c', 12}, {'d', 13},
    {'e', 14}, {'f', 15}
  };
  //pthread_mutex_lock(&mutexMemory);
  char *mstr = strdup(value);
  //pthread_mutex_unlock(&mutexMemory);
  char *s = mstr;
  int result = 0;
  if (*s == '0' && *(s + 1) == 'X') s += 2;
  bool firsttime = true;
  while (*s != '\0')
  {
    bool found = false;
    for (int i = 0; i < HexMapL; i++)
    {
      if (*s == HexMap[i].chr)
      {
        if (!firsttime) result <<= 4;
        result |= HexMap[i].value;
        found = true;
        break;
      }
    }
    if (!found) break;
    s++;
    firsttime = false;
  }
  //pthread_mutex_lock(&mutexMemory);
  free(mstr);
  //pthread_mutex_unlock(&mutexMemory);
  return result;
}


CMD5::CMD5(const char* md5src)
{
	if (strcmp(md5src,"")==0)
	{
		for(int i=0;i<4;i++)
			m_data[i]=0;
		return;
	}
	for(int j = 0; j < 16; j++ )
    {
		char buf[10];
		strncpy(buf,md5src,2);
		md5src+=2;
        ((unsigned char*)m_data)[j] = _httoi(buf);
    }
}

CMD5 CMD5::operator +(CMD5 adder)
{
	unsigned long m_newdata[4];
	for(int i=0;i<4;i++)
		m_newdata[i]=m_data[i]^(adder.m_data[i]);
	return CMD5(m_newdata);
}

bool CMD5::operator ==(CMD5 cmper)
{
	return (memcmp(cmper.m_data ,m_data,16)==0);
}

//void CMD5::operator =(CMD5 equer)
//{
//	memcpy(m_data,equer.m_data ,16);
//}

string CMD5::ToString()
{
    char output[33];
    for(int j = 0; j < 16; j++ )
    {
        sprintf( output + j * 2, "%02x", ((unsigned char*)m_data)[j]);
    }
    return string(output);
}




version:1.0
url:txtfile//.svn/text-base/.tianwang.raw.svn-base
length:16101

???
version:1.0
url:txtfile/Md5.cpp
length:9225

/*
 * RFC 1321 compliant MD5 implementation,
 * by Christophe Devine <devine@cr0.net>;
 * this program is licensed under the GPL.
 */
#include "Md5.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define GET_UINT32(n,b,i)                                       \
{                                                               \
    (n) = (uint32) ((uint8 *) b)[(i)]                           \
      | (((uint32) ((uint8 *) b)[(i)+1]) <<  8)                 \
      | (((uint32) ((uint8 *) b)[(i)+2]) << 16)                 \
      | (((uint32) ((uint8 *) b)[(i)+3]) << 24);                \
}

#define PUT_UINT32(n,b,i)                                       \
{                                                               \
    (((uint8 *) b)[(i)]  ) = (uint8) (((n)      ) & 0xFF);      \
    (((uint8 *) b)[(i)+1]) = (uint8) (((n) >>  8) & 0xFF);      \
    (((uint8 *) b)[(i)+2]) = (uint8) (((n) >> 16) & 0xFF);      \
    (((uint8 *) b)[(i)+3]) = (uint8) (((n) >> 24) & 0xFF);      \
}

//extern pthread_mutex_t mutexMemory;

void CMD5::md5_starts( struct md5_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
}

void CMD5::md5_process( struct md5_context *ctx, uint8 data[64] )
{
    uint32 A, B, C, D, X[16];

    GET_UINT32( X[0],  data,  0 );
    GET_UINT32( X[1],  data,  4 );
    GET_UINT32( X[2],  data,  8 );
    GET_UINT32( X[3],  data, 12 );
    GET_UINT32( X[4],  data, 16 );
    GET_UINT32( X[5],  data, 20 );
    GET_UINT32( X[6],  data, 24 );
    GET_UINT32( X[7],  data, 28 );
    GET_UINT32( X[8],  data, 32 );
    GET_UINT32( X[9],  data, 36 );
    GET_UINT32( X[10], data, 40 );
    GET_UINT32( X[11], data, 44 );
    GET_UINT32( X[12], data, 48 );
    GET_UINT32( X[13], data, 52 );
    GET_UINT32( X[14], data, 56 );
    GET_UINT32( X[15], data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))

#define P(a,b,c,d,k,s,t)                                \
{                                                       \
    a += F(b,c,d) + X[k] + t; a = S(a,s) + b;           \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
    P( C, D, A, B,  2, 17, 0x242070DB );
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
    P( D, A, B, C,  5, 12, 0x4787C62A );
    P( C, D, A, B,  6, 17, 0xA8304613 );
    P( B, C, D, A,  7, 22, 0xFD469501 );
    P( A, B, C, D,  8,  7, 0x698098D8 );
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
    P( B, C, D, A, 11, 22, 0x895CD7BE );
    P( A, B, C, D, 12,  7, 0x6B901122 );
    P( D, A, B, C, 13, 12, 0xFD987193 );
    P( C, D, A, B, 14, 17, 0xA679438E );
    P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
    P( D, A, B, C,  6,  9, 0xC040B340 );
    P( C, D, A, B, 11, 14, 0x265E5A51 );
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
    P( A, B, C, D,  5,  5, 0xD62F105D );
    P( D, A, B, C, 10,  9, 0x02441453 );
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
    P( D, A, B, C, 14,  9, 0xC33707D6 );
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
    P( B, C, D, A,  8, 20, 0x455A14ED );
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
    P( C, D, A, B,  7, 14, 0x676F02D9 );
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F
    
#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
    P( D, A, B, C,  8, 11, 0x8771F681 );
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
    P( B, C, D, A, 14, 23, 0xFDE5380C );
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
    P( D, A, B, C,  0, 11, 0xEAA127FA );
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
    P( B, C, D, A,  6, 23, 0x04881D05 );
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
    P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
    P( D, A, B, C,  7, 10, 0x432AFF97 );
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
    P( B, C, D, A,  5, 21, 0xFC93A039 );
    P( A, B, C, D, 12,  6, 0x655B59C3 );
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
    P( B, C, D, A,  1, 21, 0x85845DD1 );
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
    P( C, D, A, B,  6, 15, 0xA3014314 );
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
    P( A, B, C, D,  4,  6, 0xF7537E82 );
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
}

void CMD5::md5_update( struct md5_context *ctx, uint8 *input, uint32 length )
{
    uint32 left, fill;

    if( ! length ) return;

    left = ( ctx->total[0] >> 3 ) & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length <<  3;
    ctx->total[1] += length >> 29;

    ctx->total[0] &= 0xFFFFFFFF;
    ctx->total[1] += ctx->total[0] < length << 3;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, fill );
        md5_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    {
        md5_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, length );
    }
}

static uint8 md5_padding[64] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void CMD5::md5_finish( struct md5_context *ctx, uint8 digest[16] )
{
    uint32 last, padn;
    uint8 msglen[8];

    PUT_UINT32( ctx->total[0], msglen, 0 );
    PUT_UINT32( ctx->total[1], msglen, 4 );

    last = ( ctx->total[0] >> 3 ) & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    md5_update( ctx, md5_padding, padn );
    md5_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    PUT_UINT32( ctx->state[1], digest,  4 );
    PUT_UINT32( ctx->state[2], digest,  8 );
    PUT_UINT32( ctx->state[3], digest, 12 );
}

void CMD5::GenerateMD5(unsigned char* buffer,int bufferlen)
{
	struct md5_context context;
	md5_starts (&context);
	md5_update (&context, buffer, bufferlen);
	md5_finish (&context,(unsigned char*)m_data);
}

CMD5::CMD5()
{
	for(int i=0;i<4;i++)
		m_data[i]=0;
}

CMD5::CMD5(unsigned long* md5src)
{
	memcpy(m_data,md5src,16);
}
int _httoi(const char *value)
{
  struct CHexMap
  {
    char chr;
    int value;
  };
  const int HexMapL = 16;
  CHexMap HexMap[HexMapL] =
  {
    {'0', 0}, {'1', 1},
    {'2', 2}, {'3', 3},
    {'4', 4}, {'5', 5},
    {'6', 6}, {'7', 7},
    {'8', 8}, {'9', 9},
    {'a', 10}, {'b', 11},
    {'c', 12}, {'d', 13},
    {'e', 14}, {'f', 15}
  };
  //pthread_mutex_lock(&mutexMemory);
  char *mstr = strdup(value);
  //pthread_mutex_unlock(&mutexMemory);
  char *s = mstr;
  int result = 0;
  if (*s == '0' && *(s + 1) == 'X') s += 2;
  bool firsttime = true;
  while (*s != '\0')
  {
    bool found = false;
    for (int i = 0; i < HexMapL; i++)
    {
      if (*s == HexMap[i].chr)
      {
        if (!firsttime) result <<= 4;
        result |= HexMap[i].value;
        found = true;
        break;
      }
    }
    if (!found) break;
    s++;
    firsttime = false;
  }
  //pthread_mutex_lock(&mutexMemory);
  free(mstr);
  //pthread_mutex_unlock(&mutexMemory);
  return result;
}


CMD5::CMD5(const char* md5src)
{
	if (strcmp(md5src,"")==0)
	{
		for(int i=0;i<4;i++)
			m_data[i]=0;
		return;
	}
	for(int j = 0; j < 16; j++ )
    {
		char buf[10];
		strncpy(buf,md5src,2);
		md5src+=2;
        ((unsigned char*)m_data)[j] = _httoi(buf);
    }
}

CMD5 CMD5::operator +(CMD5 adder)
{
	unsigned long m_newdata[4];
	for(int i=0;i<4;i++)
		m_newdata[i]=m_data[i]^(adder.m_data[i]);
	return CMD5(m_newdata);
}

bool CMD5::operator ==(CMD5 cmper)
{
	return (memcmp(cmper.m_data ,m_data,16)==0);
}

//void CMD5::operator =(CMD5 equer)
//{
//	memcpy(m_data,equer.m_data ,16);
//}

string CMD5::ToString()
{
    char output[33];
    for(int j = 0; j < 16; j++ )
    {
        sprintf( output + j * 2, "%02x", ((unsigned char*)m_data)[j]);
    }
    return string(output);
}




version:1.0
url:txtfile/DocSegment.cpp
length:3864

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <vector>

#include "Md5.h"
#include "Url.h"
#include "Document.h"
#include "ChSeg/Dict.h"
#include "ChSeg/HzSeg.h"
#include "StrFun.h"

CDict iDict;

using namespace std;

const unsigned int HEADER_BUF_SIZE = 1024;
//const unsigned int MAX_DOC_ID = 12932;		// you should change according "Doc.idx"
const unsigned int MAX_DOC_ID = 21312;

int main(int argc, char* argv[])
{
	string strLine, strFileName=argv[1];
	CUrl iUrl;
	vector<CUrl> vecCUrl;
	CDocument iDocument;
	vector<CDocument> vecCDocument;
	unsigned int docId = 0;

	//ifstream ifs("Tianwang.raw.2559638448");
	ifstream ifs(strFileName.c_str());
	if (!ifs) {
		cerr << "Cannot open tianwang.img.info for input\n";
                return -1;
        }

	ifstream ifsUrl("Url.idx.sort_uniq");
        if (!ifsUrl) {
                cerr << "Cannot open Url.idx.sort_uniq for input\n";
                return -1;
        }
	ifstream ifsDoc("Doc.idx");
        if (!ifsDoc) {
                cerr << "Cannot open Doc.idx for input\n";
                return -1;
        }

	while (getline(ifsUrl,strLine)){
		char chksum[33];
		int  docid;

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%s%d", chksum, &docid );
		iUrl.m_sChecksum = chksum;
		iUrl.m_nDocId = docid;
		vecCUrl.push_back(iUrl);
	}

	while (getline(ifsDoc,strLine)){
		int docid,pos,length;
		char chksum[33];

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%d%d%d%s", &docid, &pos, &length,chksum );
		iDocument.m_nDocId = docid;
		iDocument.m_nPos = pos;
		iDocument.m_nLength = length;
		iDocument.m_sChecksum = chksum;
		vecCDocument.push_back(iDocument);
	}

/*
	// find page according to a url
	// ===================================
	string c,key;
	cin >> c;
	if( c == "c" ) return(0);


	CMD5 iMD5;
	iMD5.GenerateMD5( (unsigned char*)c.c_str(), c.size() );
	key = iMD5.ToString();

	int low=0, high = vecCUrl.size()-1, mid = 0;

	cout << "url: " << c << " len: " << c.size() << endl;
	cout << "md5: " << key << endl;
	cout << "high: " << high << endl;

	bool bFound = false;
	while (low <= high ){
		mid = (low+high)/2;

		if ( key == vecCUrl[mid].m_sChecksum ){
			docId = vecCUrl[mid].m_nDocId;
			// cout << docId << endl;
			bFound = true;
			break;
		} else if ( key < vecCUrl[mid].m_sChecksum ){
			high = mid -1;
		} else {
			low = mid + 1;
		}
	}

	if (!bFound){ 
		cout << "not found" << endl;
		return(0);
	}

	return(0);
	//==============================
*/


	strFileName += ".seg";
	ofstream fout(strFileName.c_str(), ios::in|ios::out|ios::trunc|ios::binary);
	for ( docId=0; docId<MAX_DOC_ID; docId++ ){

		// find document according to docId
		int length = vecCDocument[docId+1].m_nPos - vecCDocument[docId].m_nPos -1;
		char *pContent = new char[length+1];
		memset(pContent, 0, length+1);
		ifs.seekg(vecCDocument[docId].m_nPos);
		ifs.read(pContent, length);

		char *s;
		s = pContent;

		// skip Head
		int bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;


		// skip header
		bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;

		//iDocument.m_sBody = s;
		iDocument.RemoveTags(s);
		iDocument.m_sBodyNoTags = s;

		delete[] pContent;
		string strLine = iDocument.m_sBodyNoTags;

                CStrFun::ReplaceStr(strLine, "&nbsp;", " ");
		CStrFun::EmptyStr(strLine); // set " \t\r\n" to " "


		// segment the document
		CHzSeg iHzSeg;
		strLine = iHzSeg.SegmentSentenceMM(iDict,strLine);
		fout << docId << endl << strLine;
		fout << endl;
		
	}

	return(0);
}


version:1.0
url:txtfile/crawl.cpp
length:1682

#include<iostream>
#include<fstream>
#include<string>

using namespace std;

#include<sys/types.h>
#include<dirent.h>

const char RAWFILENAME[] = ".tianwang.raw";

int crawl(ofstream &raw,const char *dir_name)
{
  DIR *dir;
  dir = opendir(dir_name);
  if(dir == NULL){
    cerr<<"[ERROR]:Error in opening dir "<<dir_name<<endl;
    return -1;
  }
  struct dirent *sub;
  for(sub = readdir(dir); sub != NULL; sub = readdir(dir)){
    if(strcmp(sub->d_name,".")==0
       ||strcmp(sub->d_name,"..")==0
       ||strcmp(sub->d_name,RAWFILENAME)==0) continue;
    if(sub->d_type == DT_DIR){
      cerr<<"[DEBUG]:I'm a dir"<<endl;
      crawl(raw,(string(dir_name)+"/"+sub->d_name).c_str());
    }
    if(sub->d_type == DT_REG){
      cerr<<"[DEBUG]:I'm a file "<<sub->d_name<<endl;
      ifstream in((string(dir_name)+"/"+sub->d_name).c_str());
      if(!in){
        cerr<<"[ERROR]:Fail to open file "<<dir_name<<'/'<<sub->d_name<<endl;
        continue;
      }
      raw<<"version:1.0"<<endl;
      raw<<"url:"<<dir_name<<'/'<<sub->d_name<<endl;
      int length;
      in.seekg(0,ios_base::end);
      length = in.tellg();
      in.seekg(0,ios_base::beg);
      raw<<"length:"<<length<<endl;
      raw<<endl;
      while(!in.eof()){
        string tmp;
        getline(in,tmp);
        raw<<tmp<<endl;
      }
      raw<<endl;
    }
  }
  return 0;
}

int main(int argc, char **argv)
{  
  ofstream raw((string(argv[1])+"/"+RAWFILENAME).c_str());
  if(!raw){
    cerr<<"[ERROR]:Error when opening tianwang raw file "<<argv[1]<<"/"<<RAWFILENAME<<" to write!"<<endl;
    return -1;
  }

  if(crawl(raw,argv[1]) != 0){
    raw.close();
    return -1;
  }

  raw.close();
  return 0;
}


version:1.0
url:txtfile/Md5.h
length:1131

#ifndef _MD5_H
#define _MD5_H

//#pragma warning(disable:4786)

#include <string>

using namespace std;

/*!
 * Manage MD5.
 */
class CMD5
{
private:
	#define uint8  unsigned char
	#define uint32 unsigned long int

	struct md5_context
	{
		uint32 total[2];
		uint32 state[4];
		uint8 buffer[64];
	};

	void md5_starts( struct md5_context *ctx );
	void md5_process( struct md5_context *ctx, uint8 data[64] );
	void md5_update( struct md5_context *ctx, uint8 *input, uint32 length );
	void md5_finish( struct md5_context *ctx, uint8 digest[16] );

public:
	//! construct a CMD5 from any buffer
	void GenerateMD5(unsigned char* buffer,int bufferlen);

	//! construct a CMD5
	CMD5();

	//! construct a md5src from char *
	CMD5(const char * md5src);

	//! construct a CMD5 from a 16 bytes md5
	CMD5(unsigned long* md5src);

	//! add a other md5
	CMD5 operator +(CMD5 adder);

	//! just if equal
	bool operator ==(CMD5 cmper);

	//! give the value from equer
	// void operator =(CMD5 equer);

	//! to a string
	string ToString();

	unsigned long m_data[4];
};
#endif /* md5.h */




version:1.0
url:txtfile//.svn/text-base/Md5.h.svn-base
length:1131

#ifndef _MD5_H
#define _MD5_H

//#pragma warning(disable:4786)

#include <string>

using namespace std;

/*!
 * Manage MD5.
 */
class CMD5
{
private:
	#define uint8  unsigned char
	#define uint32 unsigned long int

	struct md5_context
	{
		uint32 total[2];
		uint32 state[4];
		uint8 buffer[64];
	};

	void md5_starts( struct md5_context *ctx );
	void md5_process( struct md5_context *ctx, uint8 data[64] );
	void md5_update( struct md5_context *ctx, uint8 *input, uint32 length );
	void md5_finish( struct md5_context *ctx, uint8 digest[16] );

public:
	//! construct a CMD5 from any buffer
	void GenerateMD5(unsigned char* buffer,int bufferlen);

	//! construct a CMD5
	CMD5();

	//! construct a md5src from char *
	CMD5(const char * md5src);

	//! construct a CMD5 from a 16 bytes md5
	CMD5(unsigned long* md5src);

	//! add a other md5
	CMD5 operator +(CMD5 adder);

	//! just if equal
	bool operator ==(CMD5 cmper);

	//! give the value from equer
	// void operator =(CMD5 equer);

	//! to a string
	string ToString();

	unsigned long m_data[4];
};
#endif /* md5.h */


version:1.0
url:txtfile//.svn/text-base/crawl.cpp.svn-base
length:1682

#include<iostream>
#include<fstream>
#include<string>

using namespace std;

#include<sys/types.h>
#include<dirent.h>

const char RAWFILENAME[] = ".tianwang.raw";

int crawl(ofstream &raw,const char *dir_name)
{
  DIR *dir;
  dir = opendir(dir_name);
  if(dir == NULL){
    cerr<<"[ERROR]:Error in opening dir "<<dir_name<<endl;
    return -1;
  }
  struct dirent *sub;
  for(sub = readdir(dir); sub != NULL; sub = readdir(dir)){
    if(strcmp(sub->d_name,".")==0
       ||strcmp(sub->d_name,"..")==0
       ||strcmp(sub->d_name,RAWFILENAME)==0) continue;
    if(sub->d_type == DT_DIR){
      cerr<<"[DEBUG]:I'm a dir"<<endl;
      crawl(raw,(string(dir_name)+"/"+sub->d_name).c_str());
    }
    if(sub->d_type == DT_REG){
      cerr<<"[DEBUG]:I'm a file "<<sub->d_name<<endl;
      ifstream in((string(dir_name)+"/"+sub->d_name).c_str());
      if(!in){
        cerr<<"[ERROR]:Fail to open file "<<dir_name<<'/'<<sub->d_name<<endl;
        continue;
      }
      raw<<"version:1.0"<<endl;
      raw<<"url:"<<dir_name<<'/'<<sub->d_name<<endl;
      int length;
      in.seekg(0,ios_base::end);
      length = in.tellg();
      in.seekg(0,ios_base::beg);
      raw<<"length:"<<length<<endl;
      raw<<endl;
      while(!in.eof()){
        string tmp;
        getline(in,tmp);
        raw<<tmp<<endl;
      }
      raw<<endl;
    }
  }
  return 0;
}

int main(int argc, char **argv)
{  
  ofstream raw((string(argv[1])+"/"+RAWFILENAME).c_str());
  if(!raw){
    cerr<<"[ERROR]:Error when opening tianwang raw file "<<argv[1]<<"/"<<RAWFILENAME<<" to write!"<<endl;
    return -1;
  }

  if(crawl(raw,argv[1]) != 0){
    raw.close();
    return -1;
  }

  raw.close();
  return 0;
}


version:1.0
url:txtfile//.svn/text-base/DocSegment.cpp.svn-base
length:3864

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <vector>

#include "Md5.h"
#include "Url.h"
#include "Document.h"
#include "ChSeg/Dict.h"
#include "ChSeg/HzSeg.h"
#include "StrFun.h"

CDict iDict;

using namespace std;

const unsigned int HEADER_BUF_SIZE = 1024;
//const unsigned int MAX_DOC_ID = 12932;		// you should change according "Doc.idx"
const unsigned int MAX_DOC_ID = 21312;

int main(int argc, char* argv[])
{
	string strLine, strFileName=argv[1];
	CUrl iUrl;
	vector<CUrl> vecCUrl;
	CDocument iDocument;
	vector<CDocument> vecCDocument;
	unsigned int docId = 0;

	//ifstream ifs("Tianwang.raw.2559638448");
	ifstream ifs(strFileName.c_str());
	if (!ifs) {
		cerr << "Cannot open tianwang.img.info for input\n";
                return -1;
        }

	ifstream ifsUrl("Url.idx.sort_uniq");
        if (!ifsUrl) {
                cerr << "Cannot open Url.idx.sort_uniq for input\n";
                return -1;
        }
	ifstream ifsDoc("Doc.idx");
        if (!ifsDoc) {
                cerr << "Cannot open Doc.idx for input\n";
                return -1;
        }

	while (getline(ifsUrl,strLine)){
		char chksum[33];
		int  docid;

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%s%d", chksum, &docid );
		iUrl.m_sChecksum = chksum;
		iUrl.m_nDocId = docid;
		vecCUrl.push_back(iUrl);
	}

	while (getline(ifsDoc,strLine)){
		int docid,pos,length;
		char chksum[33];

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%d%d%d%s", &docid, &pos, &length,chksum );
		iDocument.m_nDocId = docid;
		iDocument.m_nPos = pos;
		iDocument.m_nLength = length;
		iDocument.m_sChecksum = chksum;
		vecCDocument.push_back(iDocument);
	}

/*
	// find page according to a url
	// ===================================
	string c,key;
	cin >> c;
	if( c == "c" ) return(0);


	CMD5 iMD5;
	iMD5.GenerateMD5( (unsigned char*)c.c_str(), c.size() );
	key = iMD5.ToString();

	int low=0, high = vecCUrl.size()-1, mid = 0;

	cout << "url: " << c << " len: " << c.size() << endl;
	cout << "md5: " << key << endl;
	cout << "high: " << high << endl;

	bool bFound = false;
	while (low <= high ){
		mid = (low+high)/2;

		if ( key == vecCUrl[mid].m_sChecksum ){
			docId = vecCUrl[mid].m_nDocId;
			// cout << docId << endl;
			bFound = true;
			break;
		} else if ( key < vecCUrl[mid].m_sChecksum ){
			high = mid -1;
		} else {
			low = mid + 1;
		}
	}

	if (!bFound){ 
		cout << "not found" << endl;
		return(0);
	}

	return(0);
	//==============================
*/


	strFileName += ".seg";
	ofstream fout(strFileName.c_str(), ios::in|ios::out|ios::trunc|ios::binary);
	for ( docId=0; docId<MAX_DOC_ID; docId++ ){

		// find document according to docId
		int length = vecCDocument[docId+1].m_nPos - vecCDocument[docId].m_nPos -1;
		char *pContent = new char[length+1];
		memset(pContent, 0, length+1);
		ifs.seekg(vecCDocument[docId].m_nPos);
		ifs.read(pContent, length);

		char *s;
		s = pContent;

		// skip Head
		int bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;


		// skip header
		bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;

		//iDocument.m_sBody = s;
		iDocument.RemoveTags(s);
		iDocument.m_sBodyNoTags = s;

		delete[] pContent;
		string strLine = iDocument.m_sBodyNoTags;

                CStrFun::ReplaceStr(strLine, "&nbsp;", " ");
		CStrFun::EmptyStr(strLine); // set " \t\r\n" to " "


		// segment the document
		CHzSeg iHzSeg;
		strLine = iHzSeg.SegmentSentenceMM(iDict,strLine);
		fout << docId << endl << strLine;
		fout << endl;
		
	}

	return(0);
}


version:1.0
url:txtfile//.svn/entries
length:784

8

dir
4
https://jsepku.googlecode.com/svn/trunk/src/txtfile
https://jsepku.googlecode.com/svn



2007-12-22T02:59:34.664500Z
4
joyanlj


svn:special svn:externals svn:needs-lock

Md5.cpp
file




2007-12-22T02:54:30.000000Z
d715ecb198675cc8f2cb8832f4cf5d0e
2007-12-22T02:59:34.664500Z
4
joyanlj

DocSegment.cpp
file




2007-12-22T02:54:30.000000Z
f729865cf04afa4d1de2baf793f08a7e
2007-12-22T02:59:34.664500Z
4
joyanlj

crawl.cpp
file




2007-12-22T02:54:30.000000Z
38e2cdca3389f3ca07b9490dbad6f8af
2007-12-22T02:59:34.664500Z
4
joyanlj

Md5.h
file




2007-12-22T02:54:30.000000Z
2d5f43126df2bcaa049bf3096c12a857
2007-12-22T02:59:34.664500Z
4
joyanlj

.tianwang.raw
file




2007-12-22T02:57:17.000000Z
d0225282136192964504e21c9c61d931
2007-12-22T02:59:34.664500Z
4
joyanlj



version:1.0
url:txtfile//Md5.h
length:1131

#ifndef _MD5_H
#define _MD5_H

//#pragma warning(disable:4786)

#include <string>

using namespace std;

/*!
 * Manage MD5.
 */
class CMD5
{
private:
	#define uint8  unsigned char
	#define uint32 unsigned long int

	struct md5_context
	{
		uint32 total[2];
		uint32 state[4];
		uint8 buffer[64];
	};

	void md5_starts( struct md5_context *ctx );
	void md5_process( struct md5_context *ctx, uint8 data[64] );
	void md5_update( struct md5_context *ctx, uint8 *input, uint32 length );
	void md5_finish( struct md5_context *ctx, uint8 digest[16] );

public:
	//! construct a CMD5 from any buffer
	void GenerateMD5(unsigned char* buffer,int bufferlen);

	//! construct a CMD5
	CMD5();

	//! construct a md5src from char *
	CMD5(const char * md5src);

	//! construct a CMD5 from a 16 bytes md5
	CMD5(unsigned long* md5src);

	//! add a other md5
	CMD5 operator +(CMD5 adder);

	//! just if equal
	bool operator ==(CMD5 cmper);

	//! give the value from equer
	// void operator =(CMD5 equer);

	//! to a string
	string ToString();

	unsigned long m_data[4];
};
#endif /* md5.h */


version:1.0
url:txtfile//readme.txt
length:87

./ExSeg test1.txt
	then get test1.txt.seg

last modified by YAN Hongfei on Apr.19 2004


version:1.0
url:txtfile//testURL.txt
length:917

http://net.cs.pku.edu.cn/~webg/src/ChSeg/
new/display/29242.html
北京大学百年校庆
http://life.newyouth.beida-online.com/images/logo-life.gif
http://life.newyouth.beida-online.com/zutu/picSmall/01_%C4%DE%C9%D1_Dior%20winter20022003_%B1%A5%BA%CD%B5%C4%BA%EC%C9%AB%A3%AC%BE%AB%D6%C2%B5%C4%BB%A8%B1%DF%B4%CC%D0%E5%A3%ACGalliano%C1%EE%C8%CB%CA%EC%CF%A4%B5%C4%B7%E7%B8%F1.jpg
http://life.newyouth.beida-online.com/zutu/picSmall/02_%C4%DE%C9%D1_Dior%20winter20022003_%D0%E4%D7%D3%B5%C4%BB%A8%CE%C6%B9%F6%B1%DF%A3%AC%D5%EB%D6%AF%B3%AC%B6%CC%C8%B9%BC%D3%C9%CF%D0%DD%CF%D0%C9%CF%D7%B0%B5%C4%CD%AC%C9%AB%C5%E4%B4%EE%A3%ACDior%B5%C4%D3%D6%D2%BB%D6%D6new%20look%A1%A3.jpg
http://life.newyouth.beida-online.com/zutu/picSmall/03_%C4%DE%C9%D1_Dior%20winter20022003_%D4%CB%B6%AF%B5%C4%D7%B0%B0%E7%BC%D3%C9%CF%C3%F1%D7%E5%BB%AF%B5%C4%C9%AB%B2%CA%A3%AC%D2%B2%C4%DC%C8%C3%C8%CB%B8%D0%BE%F5%B5%BD%C1%ED%C0%E0%B5%C4%D0%C2%CF%CA%A1%A3.jpg



version:1.0
url:txtfile//preinvert.cpp
length:1037

#include<iostream>

#include<fstream>
#include<string>
#include<iomanip>
using namespace std;
const unsigned int TERM_LEN=16;
int preinvert(string path)
{
	ifstream file1;
	file1.open(path.c_str());
	if(!file1.is_open())
	{
		cout<<"[ERROR]:file can't be opened"<<endl;
		return -1;
	}
	string file_name=path;
	/*将输出文件名由.raw.seg模式改成.piidx模式*/
	int len=file_name.length();
	len-=8;
	file_name.erase(len);/*删除最后的.raw.seg*/
	file_name+=".piidx";
	ofstream file2(file_name.c_str());
	while(!file1.eof())
	{
		string id;
		file1>>id;
		while(file1.peek()!='\n'&&!file1.eof())
		{
			string words;
			if(words.length()>TERM_LEN) continue;
			else if(words.length()<TERM_LEN&&words.length()!=0) 
			{
				for(unsigned int i=words.length();i<TERM_LEN;i++)
				{
					words[i]=' ';
				}
			}
			file1>>words;
			file2<<setw(TERM_LEN)<<left<<words<<' '<<setw(TERM_LEN)<<left<<id<<endl;
		}
	}
	return 0;
}
int main(int argc,char *argv[])
{
	string file_name=argv[1];
	if(preinvert(file_name) != 0){
		return -1;
	}
	return 0;
}


version:1.0
url:txtfile//docoff.cpp
length:883

#include<iostream>
#include<fstream>
#include<string>
#include<iomanip>
using namespace std;
int docoff(string path)
{
	ifstream in_raw;
	string out_name=path;
	int len=out_name.length();
	len-=4;
	out_name.erase(len);
	out_name+=".didx";
	ofstream out_didx(out_name.c_str());
	if(!out_didx.is_open())
	{
		cerr<<"[ERROR]:out-file can't be opened"<<endl;
		return -1;
	}
	in_raw.open(path.c_str());
	if(!in_raw.is_open())
	{
		cerr<<"[ERROR]:in-file can't be opened"<<endl;
		return -1;
	}
	string words;
	int id=0;
	while(!in_raw.eof())
	{
		unsigned int offset;			
		offset=in_raw.tellg();
		getline(in_raw,words);
		if(words=="version:1.0")
		{
			out_didx<<setfill('0')<<hex<<setw(8)<<id<<' '<<setfill('0')<<hex<<setw(8)<<offset<<endl;
			id++;
		}
	}
	return 0;
}
int main(int argc,char *argv[])
{
	string filename=argv[1];
	if(docoff(filename)!=0){
		return -1;
	}
	return 0;
}

version:1.0
url:txtfile//.tianwang.raw
length:16101

???
version:1.0
url:txtfile/Md5.cpp
length:9225

/*
 * RFC 1321 compliant MD5 implementation,
 * by Christophe Devine <devine@cr0.net>;
 * this program is licensed under the GPL.
 */
#include "Md5.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define GET_UINT32(n,b,i)                                       \
{                                                               \
    (n) = (uint32) ((uint8 *) b)[(i)]                           \
      | (((uint32) ((uint8 *) b)[(i)+1]) <<  8)                 \
      | (((uint32) ((uint8 *) b)[(i)+2]) << 16)                 \
      | (((uint32) ((uint8 *) b)[(i)+3]) << 24);                \
}

#define PUT_UINT32(n,b,i)                                       \
{                                                               \
    (((uint8 *) b)[(i)]  ) = (uint8) (((n)      ) & 0xFF);      \
    (((uint8 *) b)[(i)+1]) = (uint8) (((n) >>  8) & 0xFF);      \
    (((uint8 *) b)[(i)+2]) = (uint8) (((n) >> 16) & 0xFF);      \
    (((uint8 *) b)[(i)+3]) = (uint8) (((n) >> 24) & 0xFF);      \
}

//extern pthread_mutex_t mutexMemory;

void CMD5::md5_starts( struct md5_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
}

void CMD5::md5_process( struct md5_context *ctx, uint8 data[64] )
{
    uint32 A, B, C, D, X[16];

    GET_UINT32( X[0],  data,  0 );
    GET_UINT32( X[1],  data,  4 );
    GET_UINT32( X[2],  data,  8 );
    GET_UINT32( X[3],  data, 12 );
    GET_UINT32( X[4],  data, 16 );
    GET_UINT32( X[5],  data, 20 );
    GET_UINT32( X[6],  data, 24 );
    GET_UINT32( X[7],  data, 28 );
    GET_UINT32( X[8],  data, 32 );
    GET_UINT32( X[9],  data, 36 );
    GET_UINT32( X[10], data, 40 );
    GET_UINT32( X[11], data, 44 );
    GET_UINT32( X[12], data, 48 );
    GET_UINT32( X[13], data, 52 );
    GET_UINT32( X[14], data, 56 );
    GET_UINT32( X[15], data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))

#define P(a,b,c,d,k,s,t)                                \
{                                                       \
    a += F(b,c,d) + X[k] + t; a = S(a,s) + b;           \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
    P( C, D, A, B,  2, 17, 0x242070DB );
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
    P( D, A, B, C,  5, 12, 0x4787C62A );
    P( C, D, A, B,  6, 17, 0xA8304613 );
    P( B, C, D, A,  7, 22, 0xFD469501 );
    P( A, B, C, D,  8,  7, 0x698098D8 );
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
    P( B, C, D, A, 11, 22, 0x895CD7BE );
    P( A, B, C, D, 12,  7, 0x6B901122 );
    P( D, A, B, C, 13, 12, 0xFD987193 );
    P( C, D, A, B, 14, 17, 0xA679438E );
    P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
    P( D, A, B, C,  6,  9, 0xC040B340 );
    P( C, D, A, B, 11, 14, 0x265E5A51 );
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
    P( A, B, C, D,  5,  5, 0xD62F105D );
    P( D, A, B, C, 10,  9, 0x02441453 );
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
    P( D, A, B, C, 14,  9, 0xC33707D6 );
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
    P( B, C, D, A,  8, 20, 0x455A14ED );
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
    P( C, D, A, B,  7, 14, 0x676F02D9 );
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F
    
#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
    P( D, A, B, C,  8, 11, 0x8771F681 );
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
    P( B, C, D, A, 14, 23, 0xFDE5380C );
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
    P( D, A, B, C,  0, 11, 0xEAA127FA );
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
    P( B, C, D, A,  6, 23, 0x04881D05 );
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
    P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
    P( D, A, B, C,  7, 10, 0x432AFF97 );
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
    P( B, C, D, A,  5, 21, 0xFC93A039 );
    P( A, B, C, D, 12,  6, 0x655B59C3 );
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
    P( B, C, D, A,  1, 21, 0x85845DD1 );
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
    P( C, D, A, B,  6, 15, 0xA3014314 );
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
    P( A, B, C, D,  4,  6, 0xF7537E82 );
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
}

void CMD5::md5_update( struct md5_context *ctx, uint8 *input, uint32 length )
{
    uint32 left, fill;

    if( ! length ) return;

    left = ( ctx->total[0] >> 3 ) & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length <<  3;
    ctx->total[1] += length >> 29;

    ctx->total[0] &= 0xFFFFFFFF;
    ctx->total[1] += ctx->total[0] < length << 3;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, fill );
        md5_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    {
        md5_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left), (void *) input, length );
    }
}

static uint8 md5_padding[64] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void CMD5::md5_finish( struct md5_context *ctx, uint8 digest[16] )
{
    uint32 last, padn;
    uint8 msglen[8];

    PUT_UINT32( ctx->total[0], msglen, 0 );
    PUT_UINT32( ctx->total[1], msglen, 4 );

    last = ( ctx->total[0] >> 3 ) & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    md5_update( ctx, md5_padding, padn );
    md5_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    PUT_UINT32( ctx->state[1], digest,  4 );
    PUT_UINT32( ctx->state[2], digest,  8 );
    PUT_UINT32( ctx->state[3], digest, 12 );
}

void CMD5::GenerateMD5(unsigned char* buffer,int bufferlen)
{
	struct md5_context context;
	md5_starts (&context);
	md5_update (&context, buffer, bufferlen);
	md5_finish (&context,(unsigned char*)m_data);
}

CMD5::CMD5()
{
	for(int i=0;i<4;i++)
		m_data[i]=0;
}

CMD5::CMD5(unsigned long* md5src)
{
	memcpy(m_data,md5src,16);
}
int _httoi(const char *value)
{
  struct CHexMap
  {
    char chr;
    int value;
  };
  const int HexMapL = 16;
  CHexMap HexMap[HexMapL] =
  {
    {'0', 0}, {'1', 1},
    {'2', 2}, {'3', 3},
    {'4', 4}, {'5', 5},
    {'6', 6}, {'7', 7},
    {'8', 8}, {'9', 9},
    {'a', 10}, {'b', 11},
    {'c', 12}, {'d', 13},
    {'e', 14}, {'f', 15}
  };
  //pthread_mutex_lock(&mutexMemory);
  char *mstr = strdup(value);
  //pthread_mutex_unlock(&mutexMemory);
  char *s = mstr;
  int result = 0;
  if (*s == '0' && *(s + 1) == 'X') s += 2;
  bool firsttime = true;
  while (*s != '\0')
  {
    bool found = false;
    for (int i = 0; i < HexMapL; i++)
    {
      if (*s == HexMap[i].chr)
      {
        if (!firsttime) result <<= 4;
        result |= HexMap[i].value;
        found = true;
        break;
      }
    }
    if (!found) break;
    s++;
    firsttime = false;
  }
  //pthread_mutex_lock(&mutexMemory);
  free(mstr);
  //pthread_mutex_unlock(&mutexMemory);
  return result;
}


CMD5::CMD5(const char* md5src)
{
	if (strcmp(md5src,"")==0)
	{
		for(int i=0;i<4;i++)
			m_data[i]=0;
		return;
	}
	for(int j = 0; j < 16; j++ )
    {
		char buf[10];
		strncpy(buf,md5src,2);
		md5src+=2;
        ((unsigned char*)m_data)[j] = _httoi(buf);
    }
}

CMD5 CMD5::operator +(CMD5 adder)
{
	unsigned long m_newdata[4];
	for(int i=0;i<4;i++)
		m_newdata[i]=m_data[i]^(adder.m_data[i]);
	return CMD5(m_newdata);
}

bool CMD5::operator ==(CMD5 cmper)
{
	return (memcmp(cmper.m_data ,m_data,16)==0);
}

//void CMD5::operator =(CMD5 equer)
//{
//	memcpy(m_data,equer.m_data ,16);
//}

string CMD5::ToString()
{
    char output[33];
    for(int j = 0; j < 16; j++ )
    {
        sprintf( output + j * 2, "%02x", ((unsigned char*)m_data)[j]);
    }
    return string(output);
}




version:1.0
url:txtfile/DocSegment.cpp
length:3864

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <vector>

#include "Md5.h"
#include "Url.h"
#include "Document.h"
#include "ChSeg/Dict.h"
#include "ChSeg/HzSeg.h"
#include "StrFun.h"

CDict iDict;

using namespace std;

const unsigned int HEADER_BUF_SIZE = 1024;
//const unsigned int MAX_DOC_ID = 12932;		// you should change according "Doc.idx"
const unsigned int MAX_DOC_ID = 21312;

int main(int argc, char* argv[])
{
	string strLine, strFileName=argv[1];
	CUrl iUrl;
	vector<CUrl> vecCUrl;
	CDocument iDocument;
	vector<CDocument> vecCDocument;
	unsigned int docId = 0;

	//ifstream ifs("Tianwang.raw.2559638448");
	ifstream ifs(strFileName.c_str());
	if (!ifs) {
		cerr << "Cannot open tianwang.img.info for input\n";
                return -1;
        }

	ifstream ifsUrl("Url.idx.sort_uniq");
        if (!ifsUrl) {
                cerr << "Cannot open Url.idx.sort_uniq for input\n";
                return -1;
        }
	ifstream ifsDoc("Doc.idx");
        if (!ifsDoc) {
                cerr << "Cannot open Doc.idx for input\n";
                return -1;
        }

	while (getline(ifsUrl,strLine)){
		char chksum[33];
		int  docid;

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%s%d", chksum, &docid );
		iUrl.m_sChecksum = chksum;
		iUrl.m_nDocId = docid;
		vecCUrl.push_back(iUrl);
	}

	while (getline(ifsDoc,strLine)){
		int docid,pos,length;
		char chksum[33];

		memset(chksum, 0, 33);
		sscanf( strLine.c_str(), "%d%d%d%s", &docid, &pos, &length,chksum );
		iDocument.m_nDocId = docid;
		iDocument.m_nPos = pos;
		iDocument.m_nLength = length;
		iDocument.m_sChecksum = chksum;
		vecCDocument.push_back(iDocument);
	}

/*
	// find page according to a url
	// ===================================
	string c,key;
	cin >> c;
	if( c == "c" ) return(0);


	CMD5 iMD5;
	iMD5.GenerateMD5( (unsigned char*)c.c_str(), c.size() );
	key = iMD5.ToString();

	int low=0, high = vecCUrl.size()-1, mid = 0;

	cout << "url: " << c << " len: " << c.size() << endl;
	cout << "md5: " << key << endl;
	cout << "high: " << high << endl;

	bool bFound = false;
	while (low <= high ){
		mid = (low+high)/2;

		if ( key == vecCUrl[mid].m_sChecksum ){
			docId = vecCUrl[mid].m_nDocId;
			// cout << docId << endl;
			bFound = true;
			break;
		} else if ( key < vecCUrl[mid].m_sChecksum ){
			high = mid -1;
		} else {
			low = mid + 1;
		}
	}

	if (!bFound){ 
		cout << "not found" << endl;
		return(0);
	}

	return(0);
	//==============================
*/


	strFileName += ".seg";
	ofstream fout(strFileName.c_str(), ios::in|ios::out|ios::trunc|ios::binary);
	for ( docId=0; docId<MAX_DOC_ID; docId++ ){

		// find document according to docId
		int length = vecCDocument[docId+1].m_nPos - vecCDocument[docId].m_nPos -1;
		char *pContent = new char[length+1];
		memset(pContent, 0, length+1);
		ifs.seekg(vecCDocument[docId].m_nPos);
		ifs.read(pContent, length);

		char *s;
		s = pContent;

		// skip Head
		int bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;


		// skip header
		bytesRead = 0,newlines = 0;
		while (newlines != 2 && bytesRead != HEADER_BUF_SIZE-1) {
			if (*s == '\n')
				newlines++;
			else
				newlines = 0;
			s++;
			bytesRead++;
		}
		if (bytesRead == HEADER_BUF_SIZE-1) continue;

		//iDocument.m_sBody = s;
		iDocument.RemoveTags(s);
		iDocument.m_sBodyNoTags = s;

		delete[] pContent;
		string strLine = iDocument.m_sBodyNoTags;

                CStrFun::ReplaceStr(strLine, "&nbsp;", " ");
		CStrFun::EmptyStr(strLine); // set " \t\r\n" to " "


		// segment the document
		CHzSeg iHzSeg;
		strLine = iHzSeg.SegmentSentenceMM(iDict,strLine);
		fout << docId << endl << strLine;
		fout << endl;
		
	}

	return(0);
}


version:1.0
url:txtfile/crawl.cpp
length:1682

#include<iostream>
#include<fstream>
#include<string>

using namespace std;

#include<sys/types.h>
#include<dirent.h>

const char RAWFILENAME[] = ".tianwang.raw";

int crawl(ofstream &raw,const char *dir_name)
{
  DIR *dir;
  dir = opendir(dir_name);
  if(dir == NULL){
    cerr<<"[ERROR]:Error in opening dir "<<dir_name<<endl;
    return -1;
  }
  struct dirent *sub;
  for(sub = readdir(dir); sub != NULL; sub = readdir(dir)){
    if(strcmp(sub->d_name,".")==0
       ||strcmp(sub->d_name,"..")==0
       ||strcmp(sub->d_name,RAWFILENAME)==0) continue;
    if(sub->d_type == DT_DIR){
      cerr<<"[DEBUG]:I'm a dir"<<endl;
      crawl(raw,(string(dir_name)+"/"+sub->d_name).c_str());
    }
    if(sub->d_type == DT_REG){
      cerr<<"[DEBUG]:I'm a file "<<sub->d_name<<endl;
      ifstream in((string(dir_name)+"/"+sub->d_name).c_str());
      if(!in){
        cerr<<"[ERROR]:Fail to open file "<<dir_name<<'/'<<sub->d_name<<endl;
        continue;
      }
      raw<<"version:1.0"<<endl;
      raw<<"url:"<<dir_name<<'/'<<sub->d_name<<endl;
      int length;
      in.seekg(0,ios_base::end);
      length = in.tellg();
      in.seekg(0,ios_base::beg);
      raw<<"length:"<<length<<endl;
      raw<<endl;
      while(!in.eof()){
        string tmp;
        getline(in,tmp);
        raw<<tmp<<endl;
      }
      raw<<endl;
    }
  }
  return 0;
}

int main(int argc, char **argv)
{  
  ofstream raw((string(argv[1])+"/"+RAWFILENAME).c_str());
  if(!raw){
    cerr<<"[ERROR]:Error when opening tianwang raw file "<<argv[1]<<"/"<<RAWFILENAME<<" to write!"<<endl;
    return -1;
  }

  if(crawl(raw,argv[1]) != 0){
    raw.close();
    return -1;
  }

  raw.close();
  return 0;
}


version:1.0
url:txtfile/Md5.h
length:1131

#ifndef _MD5_H
#define _MD5_H

//#pragma warning(disable:4786)

#include <string>

using namespace std;

/*!
 * Manage MD5.
 */
class CMD5
{
private:
	#define uint8  unsigned char
	#define uint32 unsigned long int

	struct md5_context
	{
		uint32 total[2];
		uint32 state[4];
		uint8 buffer[64];
	};

	void md5_starts( struct md5_context *ctx );
	void md5_process( struct md5_context *ctx, uint8 data[64] );
	void md5_update( struct md5_context *ctx, uint8 *input, uint32 length );
	void md5_finish( struct md5_context *ctx, uint8 digest[16] );

public:
	//! construct a CMD5 from any buffer
	void GenerateMD5(unsigned char* buffer,int bufferlen);

	//! construct a CMD5
	CMD5();

	//! construct a md5src from char *
	CMD5(const char * md5src);

	//! construct a CMD5 from a 16 bytes md5
	CMD5(unsigned long* md5src);

	//! add a other md5
	CMD5 operator +(CMD5 adder);

	//! just if equal
	bool operator ==(CMD5 cmper);

	//! give the value from equer
	// void operator =(CMD5 equer);

	//! to a string
	string ToString();

	unsigned long m_data[4];
};
#endif /* md5.h */




version:1.0
url:txtfile//rawseg.cpp
length:2526

#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>

#include "Dict.h"
#include "HzSeg.h"

CDict iDict;

using namespace std;

//const unsigned int HEADER_BUF_SIZE = 1024;
//const unsigned int MAX_DOC_ID = 21312;
bool good_char(unsigned char c);
void clean(char *content,int len,string &out);
  
int main(int argc, char* argv[])
{
  string terms,in_file_name=argv[1],in_idx_name=argv[2],out_file_name=in_file_name+".seg";


  ifstream fin(in_file_name.c_str());
  if (!fin) {
    cerr << "[ERROR]:Cannot open "<<in_file_name<<" for input"<<endl;
    return -1;
  }

  
  ifstream fidx(in_idx_name.c_str());
  if (!fidx) {
    cerr << "[ERROR]:Cannot open "<<in_idx_name<<" for input"<<endl;
    return -1;
  }

  
  ofstream fout(out_file_name.c_str());
  if(!fout){
    cerr<<"[ERROR]:Cannot open "<<out_file_name<<" for output"<<endl;
    return -1;
  }

  while (!fidx.eof()){
    string idx_line;
    getline(fidx,idx_line);
    unsigned int docid = 0,offset = 0;
    if(sscanf(idx_line.c_str(),"%x %x",&docid,&offset) != 2){
      cerr<<"[ERROR]:Irregular format found when reading "<<in_idx_name<<endl;
      continue;
    }
    
    string tmp = "";
    fin.seekg(offset,ios_base::beg);
    getline(fin,tmp);
    if(tmp != "version:1.0"){
      cerr<<"[ERROR]:docid - offset wrong, cannot find \"version:1.0\" in that offset"<<endl;
    }
    while(tmp.substr(0,7) != "length:"){
      if(fin.eof()){
        cerr<<"[ERROR]:EOF found when finding the string \"length:\""<<endl;
        return -1;
      }
      getline(fin,tmp);
    }

    unsigned int length;
    if(sscanf(tmp.c_str(),"length:%d",&length) != 1){
      cerr<<"[ERROR]:error when reading the file length"<<endl;
      continue;
    }
    getline(fin,tmp);
    
    char *content = new char[length+1];
    memset(content, 0, length+1);
    fin.read(content, length);

    clean(content,length,tmp);

    delete [] content;
    
    // segment the document
    CHzSeg iHzSeg;
    tmp = iHzSeg.SegmentSentenceMM(iDict,tmp);
    fout<<hex<<setfill('0')<<setw(8)<<docid<<' '<< tmp<<endl;
  }
  return 0;
}

void clean(char *content,int len,string &out)
{
  char *curr = content;
  out = "";
  for(;curr <= content+len;curr++){
    if(good_char(*curr))
      out += *curr;
    else if(good_char(*(curr+1)))
      out += ' ';
  }
}

bool good_char(unsigned char c)
{
  if((c >= '0' && c <= '9')
     || (c >= 'A' && c <= 'Z')
     || (c >= 'a' && c <= 'z')
     || (c == '\'')
     || c >= 128)
    return true;
  else
    return false;
}


