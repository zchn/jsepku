数据结构实习大作业3


00648333 陈志杰 00648332 揭忠

一、使用方法。


二、主要流程说明：

建立部分：
(a)、某根目录下的所有的文件遍历并且结合成一个比较大的.raw类型的文件(详情请参考crawl.cpp)，
.raw类型的文件有如下特点：
    1、每个组成其的文件之间都有一至多行空行。
    2、每个组成其的文件都是以固定的格式开头,例如：都是以如下格式开始：
        v e r s i o n :1.0
	url : foo . txt
	date : Tue , 15 Apr 2003 0 8 : 1 3 : 0 6 GMT
	l e n g t h : 1 2 3 4 5

	X X X X X X X X X X X
	X X X X X X X X X X X X X
	...
	X X X X X X

	v e r s i o n :1.0
	建立此文件的优点是此后则不需要再对原文件进行重新访问，一方面能够节省访问外存的时间，另一方面是模仿实际情况，在实际的网络查询中，也不会直接去访问原文件。
(b)、通过切词的过程将每个文件都切成一个一个的词，并且利用raw.seg函数对其处理以固定的格式储存在.raw.seg类型的文件中。具体格式如下：
DocID term1 term2 ...
DocID term1 term2 ...

(c)、利用docoff函数在上一步的基础上继续改进，将文本改成.didx格式，didx格式如下：
DocID 十六进制的偏移量(例如：00002432)
DocID 十六进制的偏移量

(d)、在以上文件的基础上再一步改进，改成准倒排文件的格式(也就是.piidx格式),主要格式如下：
term1 DocID term2 DocID...
term1 DocID term2 DocID...

(e)、利用invert函数对以上文件的基础上再一步改进，改成倒排文件的格式(也就是.iidx格式),主要格式如下：
term DocID DocID Docid...
term DocID DocID ...

	此过程利用的外排序函数sort，利用外排序能够处理一些比较大的文件的排序。
	以上便是预处理的主要过程了，此步骤虽然简单，但是其优点也就是简单，在下面的过程中你将会看到一个又一个非常非常简单的步骤，但当其结合起来时确实现了一个如此复杂的功能！表面看起来似乎将其建立成文件是一种浪费空间的行为，但是在以后的过程中却要一次又一次的调用此文档，所以实际上是节省了时间和空间。

查询部分：

	首先将预处理的文件利用map_creat函数将每个词与其在文档中的位置对应起来，这样便于以后的查询。
	map类能够很好的将记录和记录的位置对应起来，对以后的查询有非常大的帮助，此时就需要用到以上那些看似多余的文档。
	然后，当输入某一短语的时候，首先调用cut_word函数对其进行切词处理，将其切成一个一个的词组，每个词组之间以空格隔开。
	接着，将此第一个词组的读入到string中，利用map查找到记录的地址，然后调用get_term函数从相应的地址中读取所需的内容，接着调用process_term函数计算此词组的权值，并储存在vector数组中，调用res_merge函数对此所有词组的vector数组进行处理，计算出所输入短语在每篇文章中的权值，然后调用serv函数按照权值大小将查询结果按照固定的模式输出。

输出部分：

	这又是此次作业的一个亮点。

三、个人心得：
	揭忠：通过此次大作业的编写，我充分体会到了将一个复杂问题简单化的方法，我认为此次作业的步骤划分绝对是一个亮点，以前总是认为一个函数实现的功能越多越好，通过此次的编写，才感觉到其实是越简单越好，充分感觉到步骤的重复性以及中间文本的重用。此次大作业通过对一些步骤的重用，将某些本来很复杂的程序很简单的实现了。